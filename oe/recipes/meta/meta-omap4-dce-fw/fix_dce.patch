diff -urp old/component-sources/ipumm_3_00_00_03/platform/ti/dce/baseimage/dce_ipu.cfg new/component-sources/ipumm_3_00_00_03/platform/ti/dce/baseimage/dce_ipu.cfg
--- old/component-sources/ipumm_3_00_00_03/platform/ti/dce/baseimage/dce_ipu.cfg	2013-04-23 16:09:35.000000000 +0200
+++ new/component-sources/ipumm_3_00_00_03/platform/ti/dce/baseimage/dce_ipu.cfg	2013-05-19 10:10:35.000000000 +0200
@@ -51,7 +51,7 @@ HeapMem.common$.gate = GateHwi.create();
 
 
 var heapMemParams			= new HeapMem.Params;
-heapMemParams.size			= 0x19FFFF0;  // TODO check this size, maybe we can go up?
+heapMemParams.size			= 0x2800000;  // TODO check this size, maybe we can go up?
 heapMemParams.sectionName	= ".systemHeap";
 var heap0					= HeapMem.create(heapMemParams);
 Memory.defaultHeapInstance	= heap0;
@@ -160,11 +160,16 @@ function loadCodec(pkg, name)
 
 loadCodec('ti.sdo.codecs.mpeg4vdec.ce.MPEG4VDEC', 'ivahd_mpeg4dec');
 loadCodec('ti.sdo.codecs.h264vdec.ce.H264VDEC',   'ivahd_h264dec');
+//loadCodec('ti.sdo.codecs.h264svcvdec.ce.H264SVCVDEC',   'ivahd_h264svcdec');
 loadCodec('ti.sdo.codecs.jpegvdec.ce.JPEGVDEC',  'ivahd_jpegvdec');
 loadCodec('ti.sdo.codecs.vc1vdec.ce.VC1VDEC',    'ivahd_vc1vdec');
 loadCodec('ti.sdo.codecs.mpeg2vdec.ce.MPEG2VDEC','ivahd_mpeg2vdec');
-loadCodec('ti.sdo.codecs.h264enc.ce.H264ENC',    'ivahd_h264enc');
-loadCodec('ti.sdo.codecs.mpeg4enc.ce.MPEG4ENC',  'ivahd_mpeg4enc');
+
+//loadCodec('ti.sdo.codecs.h264enc.ce.H264ENC',    'ivahd_h264enc');
+//loadCodec('ti.sdo.codecs.h264svcenc.ce.H264SVCENC',    'ivahd_h264svcenc');
+//loadCodec('ti.sdo.codecs.jpegvenc.ce.JPEGVENC', 'ivahd_jpegvenc');
+//loadCodec('ti.sdo.codecs.mpeg4enc.ce.MPEG4ENC',  'ivahd_mpeg4enc');
+//loadCodec('ti.sdo.codecs.vc1enc.ce.VC1ENC',    'ivahd_vc1enc');
 
 var engine         = xdc.useModule('ti.sdo.ce.Engine');
 var myEngine       = engine.create("ivahd_vidsvr", codecs);
diff -urp old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce.c new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce.c
--- old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce.c	2013-04-23 16:09:35.000000000 +0200
+++ new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce.c	2013-05-19 05:06:42.000000000 +0200
@@ -49,12 +49,10 @@
 #include <ti/sysbios/knl/Task.h>
 #include <ti/ipc/MultiProc.h>
 #include <ti/ipc/rpmsg/VirtQueue.h>
-#include <ti/pm/IpcPower.h>
 
 #include <ti/sdo/ce/Engine.h>
 #include <ti/sdo/ce/video3/viddec3.h>
 #include <ti/sdo/ce/video2/videnc2.h>
-#include <ti/sdo/fc/utils/fcutils.h>
 #include <ti/xdais/dm/xdm.h>
 #include <ti/sysbios/hal/Cache.h>
 
@@ -66,7 +64,6 @@
 
 #define DCE_PORT 42     /* so long, and thanks for all the fish */
 
-uint32_t suspend_initialised = 0;
 uint32_t dce_debug = 1;
 
 #define MEMORYSTATS_DEBUG
@@ -125,26 +122,6 @@ static struct {
 #define VERSION_SIZE 128
 static char version_buffer[VERSION_SIZE];
 
-/* the following callbacks are needed for suspend/resume
- * on the linux side.
- * - FC_suspend() waits for all algorithms to get deactivated and
- * and takes care of the resources acquired.
- * - FC_resume() does nothing for now, but we add it just in case
- * it gets populated in the future versions of framework components.
- *
- * Forced off mode during video decode/encode is not supported. */
-static void dce_suspend()
-{
-	INFO("Preparing for suspend...");
-	FC_suspend();
-}
-
-static void dce_resume()
-{
-	INFO("Restoring after suspend...");
-	FC_resume();
-}
-
 static void get_videnc2_version(VIDENC2_Handle h, char *buffer, unsigned size)
 {
     VIDENC2_DynamicParams params = {
@@ -284,14 +261,6 @@ static int connect(void *msg)
 
     ivahd_init(req->chipset_id);
 
-    if (!suspend_initialised) {
-
-    /* registering sysbios-rpmsg callbacks for suspend/resume */
-    IpcPower_registerCallback(IpcPower_Event_SUSPEND, (IpcPower_CallbackFuncPtr)dce_suspend, 0);
-    IpcPower_registerCallback(IpcPower_Event_RESUME, (IpcPower_CallbackFuncPtr)dce_resume, 0);
-    suspend_initialised++;
-    }
-
     DEBUG("<<");
 
     return 0;
@@ -332,11 +301,9 @@ static int codec_create(void *msg)
     DEBUG(">> engine=%08x, name=%s, sparams=%p, codec_id=%d",
             req->engine, req->name, sparams, req->codec_id);
     DEBUG("   sparams size: %d", ((int32_t *)sparams)[0]);
-    ivahd_acquire();
     rsp->codec = (uint32_t)codec_fxns[req->codec_id].create(
             (Engine_Handle)req->engine, req->name, sparams);
     dce_clean(sparams);
-    ivahd_release();
     DEBUG("<< codec=%08x", rsp->codec);
 
 #ifdef MEMORYSTATS_DEBUG
@@ -359,12 +326,10 @@ static int codec_control(void *msg)
             req->codec, req->cmd_id, dparams, status, req->codec_id);
     DEBUG("   dparams size: %d", ((int32_t *)dparams)[0]);
     DEBUG("   status size:  %d", ((int32_t *)status)[0]);
-    ivahd_acquire();
     rsp->result = codec_fxns[req->codec_id].control(
             (void *)req->codec, req->cmd_id, dparams, status);
     dce_clean(dparams);
     dce_clean(status);
-    ivahd_release();
     DEBUG("<< ret=%d", rsp->result);
 
     return sizeof(*rsp);
@@ -498,18 +463,21 @@ static int codec_process(void *msg)
 
     rsp->result = IALG_EOK;
 
-    ivahd_acquire();
     if (req->reloc_len)
         rsp->result = codec_fxns[codec_id].reloc(
                 (void *)req->codec, reloc, (req->reloc_len * 4));
 
     if (rsp->result == IALG_EOK) {
+        ivahd_acquire();
+
         rsp->result = codec_fxns[codec_id].process(
                 (void *)req->codec, in_bufs, out_bufs, in_args, out_args);
+
+        ivahd_release();
+
     } else {
         DEBUG("reloc failed");
     }
-    ivahd_release();
 
     DEBUG("<< ret=%d", rsp->result);
 
@@ -550,9 +518,7 @@ static int codec_delete(void *msg)
     struct dce_rpc_codec_delete_req *req = msg;
 
     DEBUG(">> codec=%08x, codec_id=%d", req->codec, req->codec_id);
-    ivahd_acquire();
     codec_fxns[req->codec_id].delete((void *)req->codec);
-    ivahd_release();
     DEBUG("<<");
 
 #ifdef MEMORYSTATS_DEBUG
@@ -645,6 +611,7 @@ Bool dce_init(void)
     Task_Params_init(&params);
     params.instance->name = "dce-server";
     params.priority = Thread_Priority_ABOVE_NORMAL;
+    params.stackSize = 10000;
     Task_create(dce_main, &params, NULL);
 
     return TRUE;
diff -urp old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce_priv.h new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce_priv.h
--- old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce_priv.h	2013-04-23 16:09:35.000000000 +0200
+++ new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/dce_priv.h	2013-05-19 05:19:13.000000000 +0200
@@ -50,7 +50,6 @@ Bool dce_init(void);
 void ivahd_acquire(void);
 void ivahd_release(void);
 void ivahd_init(uint32_t chipset_id);
-void ivahd_boot();
 #endif
 
 #ifndef   DIM
diff -urp old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/ivahd.c new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/ivahd.c
--- old/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/ivahd.c	2013-04-23 16:09:35.000000000 +0200
+++ new/component-sources/ipumm_3_00_00_03/src/ti/framework/dce/ivahd.c	2013-05-18 22:46:10.000000000 +0200
@@ -60,6 +60,7 @@
 
 static uint32_t ivahd_base = 0;
 static uint32_t ivahd_m5div = 0x1f;
+static uint32_t cm_ivahd_base = 0;
 
 static uint32_t get_ivahd_base(void)
 {
@@ -72,21 +73,28 @@ static uint32_t get_ivahd_base(void)
     return ivahd_base;
 }
 
+static uint32_t get_cm_ivahd_base(void)
+{
+    if (!cm_ivahd_base) {
+        ERROR("Chipset ID not set!");
+        while (TRUE) {
+            asm(" wfi");
+        }
+    }
+    return cm_ivahd_base;
+}
+
 #define IVAHD_REG(off)            (*(volatile unsigned int *)(get_ivahd_base() + (off)))
 
-#define PM_IVAHD_PWRSTCTRL        IVAHD_REG(0x00)
-#define RM_IVAHD_RSTCTRL          IVAHD_REG(0x10)
-#define RM_IVAHD_RSTST            IVAHD_REG(0x14)
-
-#ifdef OMAP5_ES10
- #define CM_IVAHD_CLKSTCTRL        (*(volatile unsigned int *)0xAA008F00)
- #define CM_IVAHD_CLKCTRL          (*(volatile unsigned int *)0xAA008F20)
- #define CM_IVAHD_SL2_CLKCTRL      (*(volatile unsigned int *)0xAA008F28)
-#else
- #define CM_IVAHD_CLKSTCTRL        (*(volatile unsigned int *)0xAA009200)
- #define CM_IVAHD_CLKCTRL          (*(volatile unsigned int *)0xAA009220)
- #define CM_IVAHD_SL2_CLKCTRL      (*(volatile unsigned int *)0xAA009228)
-#endif //OMAP5_ES10
+#define PM_IVAHD_PWRSTCTRL        IVAHD_REG(0xF00)
+#define RM_IVAHD_RSTCTRL          IVAHD_REG(0xF10)
+#define RM_IVAHD_RSTST            IVAHD_REG(0xF14)
+
+#define CM_IVAHD_REG(off)         (*(volatile unsigned int *)(get_cm_ivahd_base() + (off)))
+
+#define CM_IVAHD_CLKSTCTRL        CM_IVAHD_REG(0x00)
+#define CM_IVAHD_CLKCTRL          CM_IVAHD_REG(0x20)
+#define CM_IVAHD_SL2_CLKCTRL      CM_IVAHD_REG(0x28)
 
 #define CM_DIV_M5_DPLL_IVA        (*(volatile unsigned int *)0xAA0041BC)
 
@@ -132,45 +140,34 @@ static void ivahd_boot(void)
             (unsigned int *)ICONT1_ITCM_BASE;
     volatile unsigned int *icont2_itcm_base_addr =
             (unsigned int *)ICONT2_ITCM_BASE;
+
     /*
      * Reset IVA HD, SL2 and ICONTs
      */
 
     DEBUG("Booting IVAHD...");
 
-
-    /* Sequence
-     * Apply Reset (0xAA306F10 = 0x7)
-     * Turn IVA power state to on (0xAA306F00 = 0x3)
-     * Set CM to SW WKUP (0xAA008F00 = 0x2)
-     * Set IVA CLK to Auto (0xAA008F20 = 0x1)
-     * Set SL2 CLK to Auto (0xAA008F28 = 0x1)
-     * Apply reset to ICONT1 and ICONT2 and remove SL2 reset (0xAA306F10 = 0x3)
-     * Code load ICONTs
-     * Release Reset for ICONT1 and ICONT2 (0xAA306F10 = 0x0)
-    */
-
+    /* Reset IVAHD sequencers and SL2 */
     RM_IVAHD_RSTCTRL = 0x00000007;
     sleepms(10);
 
-    /*POWERSTATE : IVAHD_PRM:PM_IVAHD_PWRSTCTRL*/
+    /* Turn IVA power state to on */
     PM_IVAHD_PWRSTCTRL = 0x00000003;
     sleepms(10);
 
-    /*IVAHD_CM2:CM_IVAHD_CLKSTCTRL = SW_WKUP*/
+    /* First put IVA into SW_WKUP mode */
     CM_IVAHD_CLKSTCTRL = 0x00000002;
     sleepms(10);
 
-    /*IVAHD_CM2:CM_IVAHD_IVAHD_CLKCTRL*/
-    CM_IVAHD_CLKCTRL= 0x00000001;
+    /* Set IVA clock to 'auto' */
+    CM_IVAHD_CLKCTRL = 0x00000001;
     sleepms(10);
 
-    /*IVAHD_CM2:CM_IVAHD_SL2_CLKCTRL*/
+    /* Set SL2 clock to 'auto' */
     CM_IVAHD_SL2_CLKCTRL = 0x00000001;
     sleepms(10);
 
     /* put ICONT1 & ICONT2 in reset and remove SL2 reset */
-    DEBUG("Putting [ICONTI ICONT2]: RESET and SL2:OutOfRESET...");
     RM_IVAHD_RSTCTRL = 0x00000003;
     sleepms(10);
 
@@ -179,15 +176,6 @@ static void ivahd_boot(void)
         *icont1_itcm_base_addr++ = icont_boot[i];
         *icont2_itcm_base_addr++ = icont_boot[i];
     }
-    sleepms(10);
-
-    RM_IVAHD_RSTCTRL = 0x00000000;
-    sleepms(10);
-
-    /*Read1 IVAHD_ROOT_CLK is running or gatng/ungating transition is on-going*/
-    DEBUG("Waiting for IVAHD to go out of reset\n");
-    while(((CM_IVAHD_CLKSTCTRL) & 0x100) & ~0x100 );
-
 }
 
 int ivahd_reset(void * handle, void * iresHandle)
@@ -246,7 +234,6 @@ int ivahd_reset(void * handle, void * ir
 
 static int ivahd_use_cnt = 0;
 
-#ifdef ENABLE_DEAD_CODE
 static inline void set_ivahd_opp(int opp)
 {
     unsigned int val;
@@ -263,14 +250,13 @@ static inline void set_ivahd_opp(int opp
     CM_DIV_M5_DPLL_IVA = (CM_DIV_M5_DPLL_IVA & ~0x0000011f) | val;
     DEBUG("CM_DIV_M5_DPLL_IVA=%08x", CM_DIV_M5_DPLL_IVA);
 }
-#endif //ENABLE_DEAD_CODE
+
 void ivahd_acquire(void)
 {
     UInt hwiKey = Hwi_disable();
     if (++ivahd_use_cnt == 1) {
         DEBUG("ivahd acquire");
-        /* switch SW_WAKEUP mode */
-        CM_IVAHD_CLKSTCTRL = 0x00000002;
+        set_ivahd_opp(100);
     } else {
         DEBUG("ivahd already acquired");
     }
@@ -282,8 +268,7 @@ void ivahd_release(void)
     UInt hwiKey = Hwi_disable();
     if (ivahd_use_cnt-- == 1) {
         DEBUG("ivahd release");
-        /* switch HW_AUTO mode */
-        CM_IVAHD_CLKSTCTRL = 0x00000003;
+        set_ivahd_opp(0);
     } else {
         DEBUG("ivahd still in use");
     }
@@ -293,10 +278,7 @@ void ivahd_release(void)
 static Bool allocFxn(IALG_MemRec *memTab, Int numRecs);
 static void freeFxn(IALG_MemRec *memTab, Int numRecs);
 
-/* ivahd_init() will be called in 2 situations :
- * - when omapdce kernel module is loaded
- * - when resuming from suspend
- */
+
 void ivahd_init(uint32_t chipset_id)
 {
     IRES_Status ret;
@@ -310,20 +292,20 @@ void ivahd_init(uint32_t chipset_id)
 
     switch (chipset_id) {
     case 0x4430:
-        ivahd_base = 0xAA306F00;
+        ivahd_base = 0xAA306000;
+	cm_ivahd_base = 0xAA008F00;
         ivahd_m5div = 0x07;
         break;
     case 0x4460:
     case 0x4470:
-        ivahd_base = 0xAA306F00;
+        ivahd_base = 0xAA306000;
+	cm_ivahd_base = 0xAA008F00;
         ivahd_m5div = 0x05;
         break;
     case 0x5430:
-        ivahd_base = 0xAAE06F00;
-        ivahd_m5div = 0x04;
-        break;
     case 0x5432:
-        ivahd_base = 0xAAE07200;
+        ivahd_base = 0xAAE06300;
+	cm_ivahd_base = 0xAA009200;
         ivahd_m5div = 0x04;
         break;
     default:
@@ -331,12 +313,11 @@ void ivahd_init(uint32_t chipset_id)
         break;
     }
 
-    DEBUG("ivahd_base=%08x, ivahd_m5div=%x", ivahd_base, ivahd_m5div);
+    DEBUG("ivahd_base=%08x, cm_ivahd_base=%08x, ivahd_m5div=%x",
+		ivahd_base, cm_ivahd_base, ivahd_m5div);
 
     /* bit of a hack.. not sure if there is a better way for this: */
-    HDVICP2_PARAMS.resetControlAddress[0] = ivahd_base + 0x10;
-
-    ivahd_acquire();
+    HDVICP2_PARAMS.resetControlAddress[0] = ivahd_base + 0xF10;
 
     CERuntime_init();
 
@@ -367,10 +348,12 @@ void ivahd_init(uint32_t chipset_id)
 
     ivahd_boot();
 
+    /* clear HSDIVDER_CLKOUT2_DIV */
+    set_ivahd_opp(0);
+
     DEBUG("RMAN_register() for HDVICP is successful");
 
 end:
-    ivahd_release();
     return;
 }
 
diff -urp old/Rules.make new/Rules.make
--- old/Rules.make	2013-04-23 16:17:24.000000000 +0200
+++ new/Rules.make	2013-05-18 11:12:43.000000000 +0200
@@ -1,12 +1,12 @@
 # Define target platform.
-PLATFORM=omap5
+PLATFORM=omap4
 REVISION=ES20
 KERNEL_VERSION=3.8.4
 UBOOT_VERSION=2013.01.1.1
 DEFAULT_LINUXKERNEL_CONFIG=omap2plus_defconfig
 DEFAULT_UBOOT_CONFIG=omap5_evm
 SMP_BUILD_CONFIG=smp_config
-DEFAULT_IPUMM_CONFIG=omap5_smp_config
+DEFAULT_IPUMM_CONFIG=omap4_smp_config
 SYSBIOS_VERSION=2_00_12_32+glsdk1
 IPUMM_VERSION=3_00_00_03
 XDC_VERSION=xdctools_3_24_03_33
