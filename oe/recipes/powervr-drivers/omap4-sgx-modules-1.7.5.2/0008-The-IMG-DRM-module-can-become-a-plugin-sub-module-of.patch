From 503105af2034a76200e1f85c8bc26cbd66d7c850 Mon Sep 17 00:00:00 2001
From: Ian Elliott <ian.elliott@intelligraphics.com>
Date: Thu, 5 May 2011 17:18:34 -0600
Subject: [PATCH 1/2] The IMG DRM module can become a plugin sub-module of a TI DRM module.

This is part of Rob Clark's work to start supporting KMS/XRandR, and set
the stage for other features that TI wants, but IMG won't want to support.
As a part of this, we want a TI DRM module (initially to provide
KMS/XRandR support).  The IMG DRM code currently thinks that it is "in
charge" as the DRM module for OMAP, using the 3rd-party display driver
(3PDD) as a sub-module.  As such, the IMG DRM registers with the main DRM
part of the kernel, and it use the 3rd-party display driver (3PDD) as a
sub-module (e.g. 3PDD ioctl's are tunneled through IMG ioctl's).

This change allows for a TI DRM module, that Rob created, to be "in charge"
(e.g. be registered with the main DRM part of the kernel).  When enabled
(with the SUPPORT_DRI_DRM_EXTERNAL macro), the IMG DRM code will register
itself as a plugin of the TI DRM module.

This is a newer version of Rob's patch set (change 108):
- v1: Original patch.
- v2: Fix problem calculating # of flip-chain buffers.
- v3: The SUPPORT_DRI_DRM_EXTERNAL macro was been turned off.
- v4: The SUPPORT_DRI_DRM_EXTERNAL macro was been turned off.
- v4: Re-based to the 1.7.2.0 DDK (with SUPPORT_DRI_DRM_EXTERNAL turned
      on).
- v5: Re-based to the latest ti_1.7 HEAD (1.7.5 4403 DDK).  This is based
      on a re-base that Rob did for the webtop repository, with the
      2.6.38 kernel.
- rsalveti's changes: removed code that touches eurasia

Signed-off-by: Ian Elliott <ian.elliott@intelligraphics.com>
Signed-off-by: Ricardo Salveti de Araujo <ricardo.salveti@canonical.com>
---
 sgx/eurasiacon/build/linux2/common/dridrm.mk       |    2 +
 .../build/linux2/omap4430_linux/Makefile           |    4 +
 .../dc_omapfb3_linux/3rdparty_dc_drm_shared.h      |    2 +
 sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h  |    2 +
 .../dc_omapfb3_linux/omaplfb_displayclass.c        |   87 +++++++++++++-------
 .../3rdparty/dc_omapfb3_linux/omaplfb_linux.c      |   10 ++-
 sgx/services4/srvkm/env/linux/module.c             |   37 +++++----
 sgx/services4/srvkm/env/linux/pvr_drm.c            |   62 +++++++++++++-
 sgx/services4/srvkm/env/linux/pvr_drm.h            |    6 +-
 9 files changed, 161 insertions(+), 51 deletions(-)

diff --git a/sgx/eurasiacon/build/linux2/common/dridrm.mk b/sgx/eurasiacon/build/linux2/common/dridrm.mk
index 5979012..86b2f08 100755
--- a/sgx/eurasiacon/build/linux2/common/dridrm.mk
+++ b/sgx/eurasiacon/build/linux2/common/dridrm.mk
@@ -25,9 +25,11 @@
 
 $(eval $(call TunableBothConfigC,SUPPORT_DRI_DRM,))
 $(eval $(call TunableBothConfigC,SUPPORT_DRI_DRM_EXT,))
+$(eval $(call TunableBothConfigC,SUPPORT_DRI_DRM_EXTERNAL,))
 
 
 $(eval $(call TunableBothConfigMake,SUPPORT_DRI_DRM,))
+$(eval $(call TunableBothConfigMake,SUPPORT_DRI_DRM_EXTERNAL,))
 
 ifeq ($(SUPPORT_DRI_DRM),1)
 ifeq ($(SUPPORT_DRI_DRM_NO_LIBDRM),1)
diff --git a/sgx/eurasiacon/build/linux2/omap4430_linux/Makefile b/sgx/eurasiacon/build/linux2/omap4430_linux/Makefile
index e2eaab3..9f4e066 100755
--- a/sgx/eurasiacon/build/linux2/omap4430_linux/Makefile
+++ b/sgx/eurasiacon/build/linux2/omap4430_linux/Makefile
@@ -43,6 +43,8 @@ include ../common/xorg_test.mk
 ifeq ($(want_xorg),1)
 SUPPORT_DRI_DRM := 1
 SUPPORT_BC_EXAMPLE ?= 0
+# support for registering as plugin into external DRM driver
+SUPPORT_DRI_DRM_EXTERNAL := 1
 else
 SUPPORT_BC_EXAMPLE ?= 1
 endif
@@ -100,9 +102,11 @@ SYS_CUSTOM_POWERLOCK_WRAP := 1
 
 ifeq ($(OMAP_KERNEL_AT_LEAST_2_6_35),1)
 ifeq ($(LDM_PLATFORM),1)
+ifneq ($(SUPPORT_DRI_DRM_EXTERNAL),1)
 PVR_LDM_PLATFORM_PRE_REGISTERED := 1
 endif
 endif
+endif
 
 BUILD_OPENCL ?= 0
 ifneq ($(BUILD_OPENCL),1)
diff --git a/sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h b/sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
index 0dee80a..d1f1966 100755
--- a/sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
+++ b/sgx/services4/3rdparty/dc_omapfb3_linux/3rdparty_dc_drm_shared.h
@@ -36,6 +36,8 @@
 #define	PVR_DRM_DISP_CMD_SUSPEND	5
 #define	PVR_DRM_DISP_CMD_OFF		6
 
+#define	PVR_DRM_DISP_CMD_RESYNC		7
+
 #define	PVR_DRM_DISP_ARG_CMD		0
 #define	PVR_DRM_DISP_ARG_DEV		1
 #define	PVR_DRM_DISP_NUM_ARGS		2
diff --git a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
index 1c92220..c1817a6 100755
--- a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
+++ b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb.h
@@ -348,5 +348,7 @@ void OMAPLFBAtomicIntSet(OMAPLFB_ATOMIC_INT *psAtomic, int iVal);
 int OMAPLFBAtomicIntRead(OMAPLFB_ATOMIC_INT *psAtomic);
 void OMAPLFBAtomicIntInc(OMAPLFB_ATOMIC_INT *psAtomic);
 
+OMAPLFB_ERROR OMAPLFBReInitFBDev(OMAPLFB_DEVINFO *psDevInfo);
+
 #endif 
 
diff --git a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
index 0ed53cf..43eedc1 100755
--- a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
+++ b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_displayclass.c
@@ -918,7 +918,9 @@ static OMAPLFB_ERROR OMAPLFBInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 	psPVRFBInfo->ulHeight = psLINFBInfo->var.yres;
 	psPVRFBInfo->ulByteStride =  psLINFBInfo->fix.line_length;
 	psPVRFBInfo->ulFBSize = FBSize;
-	psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
+	// map entire framebuffer, in case resolution is later changed upwards:
+	//psPVRFBInfo->ulBufferSize = psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride;
+	psPVRFBInfo->ulBufferSize = FBSize;
 	
 	psPVRFBInfo->ulRoundedBufferSize = RoundUpToMultiple(psPVRFBInfo->ulBufferSize, ulLCM);
 
@@ -986,6 +988,59 @@ ErrorRelSem:
 	return eError;
 }
 
+/* perform the minimal setup that is re-performed when fb dimensions change,
+ * such as calculation of # of flip chain buffers
+ */
+OMAPLFB_ERROR OMAPLFBReInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
+{
+	OMAPLFB_FBINFO *psPVRFBInfo = &psDevInfo->sFBInfo;
+	struct fb_info *psLINFBInfo = registered_fb[psDevInfo->uiFBDevID];
+	unsigned long ulRoundedBufferSize, ulLCM;
+	OMAPLFB_ERROR err;
+
+	err = OMAPLFBInitFBDev(psDevInfo);
+	if (err != OMAPLFB_OK)
+	{
+		printk(KERN_INFO DRIVER_PREFIX ": %s: Could not reinit device\n", __FUNCTION__);
+		return err;
+	}
+
+	/* note: psDevInfo->sFBInfo.ulRoundedBufferSize includes entire fb size, so that
+	 * we map entire fb memory (in case screen resolution changes).. so re-calculate
+	 * the individual buffer size:
+	 */
+	ulLCM = LCM(psLINFBInfo->fix.line_length, OMAPLFB_PAGE_SIZE);
+	ulRoundedBufferSize = RoundUpToMultiple(psPVRFBInfo->ulHeight * psPVRFBInfo->ulByteStride, ulLCM);
+
+	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / ulRoundedBufferSize);
+	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers != 0)
+	{
+		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
+		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 1;
+	}
+
+	psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
+	psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
+
+	strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
+
+	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
+	psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
+	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
+	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
+
+	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
+			": Device %u: Maximum number of swap chain buffers: %u\n",
+			psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
+
+
+	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
+	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
+	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
+
+	return OMAPLFB_OK;
+}
+
 static void OMAPLFBDeInitFBDev(OMAPLFB_DEVINFO *psDevInfo)
 {
 	struct fb_info *psLINFBInfo = psDevInfo->psLINFBInfo;
@@ -1042,42 +1097,14 @@ static OMAPLFB_DEVINFO *OMAPLFBInitDev(unsigned uiFBDevID)
 	}
 
 	
-	if(OMAPLFBInitFBDev(psDevInfo) != OMAPLFB_OK)
+	if(OMAPLFBReInitFBDev(psDevInfo) != OMAPLFB_OK)
 	{
 		
 		goto ErrorFreeDevInfo;
 	}
 
-	psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers = (IMG_UINT32)(psDevInfo->sFBInfo.ulFBSize / psDevInfo->sFBInfo.ulRoundedBufferSize);
-	if (psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers != 0)
-	{
-		psDevInfo->sDisplayInfo.ui32MaxSwapChains = 1;
-		psDevInfo->sDisplayInfo.ui32MaxSwapInterval = 1;
-	}
-
-	psDevInfo->sDisplayInfo.ui32PhysicalWidthmm = psDevInfo->sFBInfo.ulPhysicalWidthmm;
-	psDevInfo->sDisplayInfo.ui32PhysicalHeightmm = psDevInfo->sFBInfo.ulPhysicalHeightmm;
-
-	strncpy(psDevInfo->sDisplayInfo.szDisplayName, DISPLAY_DEVICE_NAME, MAX_DISPLAY_NAME_SIZE);
-
-	psDevInfo->sDisplayFormat.pixelformat = psDevInfo->sFBInfo.ePixelFormat;
-	psDevInfo->sDisplayDim.ui32Width      = (IMG_UINT32)psDevInfo->sFBInfo.ulWidth;
-	psDevInfo->sDisplayDim.ui32Height     = (IMG_UINT32)psDevInfo->sFBInfo.ulHeight;
-	psDevInfo->sDisplayDim.ui32ByteStride = (IMG_UINT32)psDevInfo->sFBInfo.ulByteStride;
-
-	DEBUG_PRINTK((KERN_INFO DRIVER_PREFIX
-		": Device %u: Maximum number of swap chain buffers: %u\n",
-		psDevInfo->uiFBDevID, psDevInfo->sDisplayInfo.ui32MaxSwapChainBuffers));
-
-	
-	psDevInfo->sSystemBuffer.sSysAddr = psDevInfo->sFBInfo.sSysAddr;
-	psDevInfo->sSystemBuffer.sCPUVAddr = psDevInfo->sFBInfo.sCPUVAddr;
-	psDevInfo->sSystemBuffer.psDevInfo = psDevInfo;
-
 	OMAPLFBInitBufferForSwap(&psDevInfo->sSystemBuffer);
 
-	
-
 	psDevInfo->sDCJTable.ui32TableSize = sizeof(PVRSRV_DC_SRV2DISP_KMJTABLE);
 	psDevInfo->sDCJTable.pfnOpenDCDevice = OpenDCDevice;
 	psDevInfo->sDCJTable.pfnCloseDCDevice = CloseDCDevice;
diff --git a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
index 6a0257b..312d49f 100755
--- a/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
+++ b/sgx/services4/3rdparty/dc_omapfb3_linux/omaplfb_linux.c
@@ -47,7 +47,6 @@
 #include <linux/workqueue.h>
 #include <linux/fb.h>
 #include <linux/console.h>
-#include <linux/omapfb.h>
 #include <linux/mutex.h>
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34))
@@ -659,6 +658,15 @@ int PVR_DRM_MAKENAME(DISPLAY_CONTROLLER, _Ioctl)(struct drm_device unref__ *dev,
 			(void) OMAPLFBUnblankDisplay(psDevInfo);
 			break;
 		}
+		case PVR_DRM_DISP_CMD_RESYNC:
+			if (OMAPLFBReInitFBDev(psDevInfo) != OMAPLFB_OK)
+			{
+				printk(KERN_WARNING DRIVER_PREFIX ": %s: ReInit failed\n", __FUNCTION__);
+				ret = -EINVAL;
+				break;
+			}
+
+			break;
 		case PVR_DRM_DISP_CMD_ON:
 		case PVR_DRM_DISP_CMD_STANDBY:
 		case PVR_DRM_DISP_CMD_SUSPEND:
diff --git a/sgx/services4/srvkm/env/linux/module.c b/sgx/services4/srvkm/env/linux/module.c
index 1685045..c8bd27a 100755
--- a/sgx/services4/srvkm/env/linux/module.c
+++ b/sgx/services4/srvkm/env/linux/module.c
@@ -32,10 +32,9 @@
 #endif
 #endif
 
-#if defined(SUPPORT_DRI_DRM)
+#if defined(SUPPORT_DRI_DRM) && !defined(SUPPORT_DRI_DRM_EXTERNAL)
 #define	PVR_MOD_STATIC
 #else
-	
 	#if defined(LDM_PLATFORM)
 		#define	PVR_LDM_PLATFORM_MODULE
 		#define	PVR_LDM_MODULE
@@ -45,8 +44,12 @@
 			#define	PVR_LDM_MODULE
 		#endif
 	#endif
+#if defined(SUPPORT_DRI_DRM_EXTERNAL)
+#define	PVR_MOD_STATIC
+#else
 #define	PVR_MOD_STATIC	static
 #endif
+#endif
 
 #if defined(PVR_LDM_PLATFORM_PRE_REGISTERED)
 #if !defined(NO_HARDWARE)
@@ -105,6 +108,9 @@
 #endif
 #define DRVNAME		PVRSRV_MODNAME
 #define DEVNAME		PVRSRV_MODNAME
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
+MODULE_SUPPORTED_DEVICE(DEVNAME);
+#endif
 
 #if defined(SUPPORT_DRI_DRM)
 #define PRIVATE_DATA(pFile) ((pFile)->driver_priv)
@@ -112,8 +118,6 @@
 #define PRIVATE_DATA(pFile) ((pFile)->private_data)
 #endif
 
-MODULE_SUPPORTED_DEVICE(DEVNAME);
-
 #if defined(PVRSRV_NEED_PVR_DPF)
 #include <linux/moduleparam.h>
 extern IMG_UINT32 gPVRDebugLevel;
@@ -125,13 +129,15 @@ MODULE_PARM_DESC(gPVRDebugLevel, "Sets the level of debug output (default 0x7)")
 EXPORT_SYMBOL(PVRGetDisplayClassJTable);
 EXPORT_SYMBOL(PVRGetBufferClassJTable);
 
-#if defined(PVR_LDM_MODULE)
+#if defined(PVR_LDM_MODULE) && !defined(SUPPORT_DRI_DRM_EXTERNAL)
 static struct class *psPvrClass;
 #endif
 
 #if !defined(SUPPORT_DRI_DRM)
 static int AssignedMajorNumber;
+#endif
 
+#if !defined(SUPPORT_DRI_DRM)
 static int PVRSRVOpen(struct inode* pInode, struct file* pFile);
 static int PVRSRVRelease(struct inode* pInode, struct file* pFile);
 
@@ -164,7 +170,7 @@ static IMG_UINT32 gPVRPowerLevel;
 #define	LDM_DEV	struct pci_dev
 #define	LDM_DRV	struct pci_driver
 #endif 
-#if defined(PVR_LDM_PLATFORM_MODULE)
+#if defined(PVR_LDM_PLATFORM_MODULE) && !defined(SUPPORT_DRI_DRM_EXTERNAL)
 static int PVRSRVDriverRemove(LDM_DEV *device);
 static int PVRSRVDriverProbe(LDM_DEV *device);
 #endif
@@ -172,9 +178,6 @@ static int PVRSRVDriverProbe(LDM_DEV *device);
 static void PVRSRVDriverRemove(LDM_DEV *device);
 static int PVRSRVDriverProbe(LDM_DEV *device, const struct pci_device_id *id);
 #endif
-static int PVRSRVDriverSuspend(LDM_DEV *device, pm_message_t state);
-static void PVRSRVDriverShutdown(LDM_DEV *device);
-static int PVRSRVDriverResume(LDM_DEV *device);
 
 #if defined(PVR_LDM_PCI_MODULE)
 struct pci_device_id powervr_id_table[] __devinitdata = {
@@ -195,6 +198,7 @@ static struct platform_device_id powervr_id_table[] __devinitdata = {
 };
 #endif
 
+#if defined(SUPPORT_DRI_DRM_EXTERNAL) || !defined(SUPPORT_DRI_DRM)
 static LDM_DRV powervr_driver = {
 #if defined(PVR_LDM_PLATFORM_MODULE)
 	.driver = {
@@ -218,6 +222,7 @@ static LDM_DRV powervr_driver = {
 	.resume		= PVRSRVDriverResume,
 	.shutdown	= PVRSRVDriverShutdown,
 };
+#endif
 
 LDM_DEV *gpsPVRLDMDev;
 
@@ -237,7 +242,7 @@ static struct platform_device powervr_device = {
 #endif
 
 #if defined(PVR_LDM_PLATFORM_MODULE)
-static int PVRSRVDriverProbe(LDM_DEV *pDevice)
+PVR_MOD_STATIC int PVRSRVDriverProbe(LDM_DEV *pDevice)
 #endif
 #if defined(PVR_LDM_PCI_MODULE)
 static int __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_device_id *id)
@@ -278,7 +283,7 @@ static int __devinit PVRSRVDriverProbe(LDM_DEV *pDevice, const struct pci_device
 
 
 #if defined (PVR_LDM_PLATFORM_MODULE)
-static int PVRSRVDriverRemove(LDM_DEV *pDevice)
+PVR_MOD_STATIC int PVRSRVDriverRemove(LDM_DEV *pDevice)
 #endif
 #if defined(PVR_LDM_PCI_MODULE)
 static void __devexit PVRSRVDriverRemove(LDM_DEV *pDevice)
@@ -317,7 +322,7 @@ static void __devexit PVRSRVDriverRemove(LDM_DEV *pDevice)
 	return;
 #endif
 }
-#endif 
+#endif
 
 
 #if defined(PVR_LDM_MODULE) || defined(PVR_DRI_DRM_PLATFORM_DEV)
@@ -526,11 +531,13 @@ static int __init PVRCore_Init(void)
 #endif
 {
 	int error;
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 #if !defined(PVR_LDM_MODULE)
 	PVRSRV_ERROR eError;
 #else
 	struct device *psDev;
 #endif
+#endif
 
 #if !defined(SUPPORT_DRI_DRM)
 	
@@ -623,7 +630,6 @@ static int __init PVRCore_Init(void)
 	}
 
 	PVR_TRACE(("PVRCore_Init: major device %d", AssignedMajorNumber));
-#endif 
 
 #if defined(PVR_LDM_MODULE)
 	
@@ -648,10 +654,11 @@ static int __init PVRCore_Init(void)
 		goto destroy_class;
 	}
 #endif 
+#endif
 
 	return 0;
 
-#if defined(PVR_LDM_MODULE)
+#if defined(PVR_LDM_MODULE) && !defined(SUPPORT_DRI_DRM_EXTERNAL)
 destroy_class:
 	class_destroy(psPvrClass);
 unregister_device:
@@ -711,7 +718,7 @@ static void __exit PVRCore_Cleanup(void)
 	SysAcquireData(&psSysData);
 #endif
 
-#if defined(PVR_LDM_MODULE)
+#if defined(PVR_LDM_MODULE) && !defined(SUPPORT_DRI_DRM_EXTERNAL)
 	device_destroy(psPvrClass, MKDEV(AssignedMajorNumber, 0));
 	class_destroy(psPvrClass);
 #endif
diff --git a/sgx/services4/srvkm/env/linux/pvr_drm.c b/sgx/services4/srvkm/env/linux/pvr_drm.c
index 3cd7a63..7aa26ba 100755
--- a/sgx/services4/srvkm/env/linux/pvr_drm.c
+++ b/sgx/services4/srvkm/env/linux/pvr_drm.c
@@ -44,6 +44,10 @@
 #include <drm/drmP.h>
 #include <drm/drm.h>
 
+#if defined(SUPPORT_DRI_DRM_EXTERNAL)
+#  include <linux/omap_gpu.h>
+#endif
+
 #include "img_defs.h"
 #include "services.h"
 #include "kerneldisplay.h"
@@ -78,6 +82,7 @@ DECLARE_WAIT_QUEUE_HEAD(sWaitForInit);
 IMG_BOOL bInitComplete;
 IMG_BOOL bInitFailed;
 
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 #if !defined(PVR_DRI_DRM_NOT_PCI)
 #if defined(PVR_DRI_DRM_PLATFORM_DEV)
 struct platform_device *gpsPVRLDMDev;
@@ -85,6 +90,7 @@ struct platform_device *gpsPVRLDMDev;
 struct pci_dev *gpsPVRLDMDev;
 #endif
 #endif
+#endif
 
 struct drm_device *gpsPVRDRMDev;
 
@@ -125,6 +131,7 @@ PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
 	PVR_TRACE(("PVRSRVDrmLoad"));
 
 	gpsPVRDRMDev = dev;
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 #if !defined(PVR_DRI_DRM_NOT_PCI)
 #if defined(PVR_DRI_DRM_PLATFORM_DEV)
 	gpsPVRLDMDev = dev->platformdev;
@@ -132,6 +139,7 @@ PVRSRVDrmLoad(struct drm_device *dev, unsigned long flags)
 	gpsPVRLDMDev = dev->pdev;
 #endif
 #endif
+#endif
 
 #if defined(PDUMP)
 	iRes = dbgdrv_init();
@@ -197,6 +205,8 @@ PVRSRVDrmUnload(struct drm_device *dev)
 DRI_DRM_STATIC int
 PVRSRVDrmOpen(struct drm_device *dev, struct drm_file *file)
 {
+	PVR_TRACE(("PVRSRVDrmOpen"));
+
 	while (!bInitComplete)
 	{
 		DEFINE_WAIT(sWait);
@@ -235,6 +245,21 @@ PVRSRVDrmPostClose(struct drm_device *dev, struct drm_file *file)
 
 	file->driver_priv = NULL;
 }
+#elif defined(SUPPORT_DRI_DRM_EXTERNAL)
+DRI_DRM_STATIC int
+PVRSRVDrmRelease(struct drm_device *dev, struct drm_file *file)
+{
+	void *psDriverPriv = file->driver_priv;
+
+	PVR_TRACE(("PVRSRVDrmRelease: psDriverPriv=%p", psDriverPriv));
+
+	if (psDriverPriv)
+	{
+		PVRSRVRelease(psDriverPriv);
+	}
+
+	return 0;
+}
 #else
 DRI_DRM_STATIC int
 PVRSRVDrmRelease(struct inode *inode, struct file *filp)
@@ -247,9 +272,9 @@ PVRSRVDrmRelease(struct inode *inode, struct file *filp)
 
 	if (ret != 0)
 	{
-		
+
 		PVR_DPF((PVR_DBG_ERROR, "%s : drm_release failed: %d",
-			__FUNCTION__, ret));
+				 __FUNCTION__, ret));
 	}
 
 	PVRSRVRelease(psDriverPriv);
@@ -355,13 +380,31 @@ struct drm_ioctl_desc sPVRDrmIoctls[] = {
 #endif
 };
 
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 static int pvr_max_ioctl = DRM_ARRAY_SIZE(sPVRDrmIoctls);
 
 #if defined(PVR_DRI_DRM_PLATFORM_DEV) && !defined(SUPPORT_DRI_DRM_EXT)
 static int PVRSRVDrmProbe(struct platform_device *pDevice);
 static int PVRSRVDrmRemove(struct platform_device *pDevice);
 #endif	
+#endif
 
+#if defined(SUPPORT_DRI_DRM_EXTERNAL)
+static struct omap_gpu_plugin plugin = {
+		.name = PVR_DRM_NAME,
+
+		.open = PVRSRVDrmOpen,
+		.load = PVRSRVDrmLoad,
+		.unload = PVRSRVDrmUnload,
+
+		.release = PVRSRVDrmRelease,
+		.mmap = PVRMMap,
+
+		.ioctls = sPVRDrmIoctls,
+		.num_ioctls = ARRAY_SIZE(sPVRDrmIoctls),
+		.ioctl_start = 0,
+};
+#else
 static struct drm_driver sPVRDrmDriver = 
 {
 #if defined(PVR_DRI_DRM_PLATFORM_DEV)
@@ -420,7 +463,9 @@ static struct drm_driver sPVRDrmDriver =
 	.minor = PVRVERSION_MIN,
 	.patchlevel = PVRVERSION_BUILD,
 };
+#endif
 
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 #if defined(PVR_DRI_DRM_PLATFORM_DEV) && !defined(SUPPORT_DRI_DRM_EXT)
 static int
 PVRSRVDrmProbe(struct platform_device *pDevice)
@@ -439,12 +484,15 @@ PVRSRVDrmRemove(struct platform_device *pDevice)
 
 	return 0;
 }
-
+#endif
 #endif	
+
 static int __init PVRSRVDrmInit(void)
 {
 	int iRes;
+#if !defined(SUPPORT_DRI_DRM_EXTERNAL)
 	sPVRDrmDriver.num_ioctls = pvr_max_ioctl;
+#endif
 
 	
 	PVRDPFInit();
@@ -457,7 +505,11 @@ static int __init PVRSRVDrmInit(void)
 	}
 #endif
 
+#if defined(SUPPORT_DRI_DRM_EXTERNAL)
+	iRes = omap_gpu_register_plugin(&plugin);
+#else
 	iRes = drm_init(&sPVRDrmDriver);
+#endif
 #if defined(PVR_DRI_DRM_NOT_PCI)
 	if (iRes != 0)
 	{
@@ -469,11 +521,15 @@ static int __init PVRSRVDrmInit(void)
 	
 static void __exit PVRSRVDrmExit(void)
 {
+#if defined(SUPPORT_DRI_DRM_EXTERNAL)
+	omap_gpu_unregister_plugin(&plugin);
+#else
 	drm_exit(&sPVRDrmDriver);
 
 #if defined(PVR_DRI_DRM_NOT_PCI)
 	drm_pvr_dev_remove();
 #endif
+#endif
 }
 
 module_init(PVRSRVDrmInit);
diff --git a/sgx/services4/srvkm/env/linux/pvr_drm.h b/sgx/services4/srvkm/env/linux/pvr_drm.h
index e0276df..f26403f 100755
--- a/sgx/services4/srvkm/env/linux/pvr_drm.h
+++ b/sgx/services4/srvkm/env/linux/pvr_drm.h
@@ -44,10 +44,12 @@ void PVRCore_Cleanup(void);
 int PVRSRVOpen(struct drm_device *dev, struct drm_file *pFile);
 void PVRSRVRelease(void *pvPrivData);
 
-#if defined(PVR_DRI_DRM_PLATFORM_DEV)
-void PVRSRVDriverShutdown(LDM_DEV *pDevice);
+#if defined(SUPPORT_DRI_DRM_EXTERNAL) || defined(PVR_DRI_DRM_PLATFORM_DEV)
+int PVRSRVDriverProbe(LDM_DEV *pDevice);
+int PVRSRVDriverRemove(LDM_DEV *pDevice);
 int PVRSRVDriverSuspend(LDM_DEV *pDevice, pm_message_t state);
 int PVRSRVDriverResume(LDM_DEV *pDevice);
+void PVRSRVDriverShutdown(LDM_DEV *pDevice);
 #else
 int PVRSRVDriverSuspend(struct drm_device *pDevice, pm_message_t state);
 int PVRSRVDriverResume(struct drm_device *pDevice);
-- 
1.7.4.1

