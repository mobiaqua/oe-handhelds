From 8e32c7e36146f185a1bd261b85dd45fc84748313 Mon Sep 17 00:00:00 2001
From: Pawel Kolodziejski <aquadran@users.sourceforge.net>
Date: Wed, 7 Dec 2011 15:53:14 +0100
Subject: [PATCH] smsc95xxx: import mac address override code

---
 drivers/net/usb/smsc95xx.c |   83 +++++++++++++++++++++++++++++++++----------
 1 files changed, 63 insertions(+), 20 deletions(-)

diff --git a/drivers/net/usb/smsc95xx.c b/drivers/net/usb/smsc95xx.c
index a0eb301..5740d7c 100644
--- a/drivers/net/usb/smsc95xx.c
+++ b/drivers/net/usb/smsc95xx.c
@@ -50,8 +50,6 @@
 
 struct smsc95xx_priv {
 	u32 mac_cr;
-	u32 hash_hi;
-	u32 hash_lo;
 	spinlock_t mac_cr_lock;
 	bool use_tx_csum;
 	bool use_rx_csum;
@@ -66,6 +64,10 @@ static int turbo_mode = true;
 module_param(turbo_mode, bool, 0644);
 MODULE_PARM_DESC(turbo_mode, "Enable multiple frames per Rx transaction");
 
+static char *macaddr = ":";
+module_param(macaddr, charp, 0);
+MODULE_PARM_DESC(macaddr, "MAC address");
+
 static int smsc95xx_read_reg(struct usbnet *dev, u32 index, u32 *data)
 {
 	u32 *buf = kmalloc(4, GFP_KERNEL);
@@ -373,11 +375,10 @@ static void smsc95xx_set_multicast(struct net_device *netdev)
 {
 	struct usbnet *dev = netdev_priv(netdev);
 	struct smsc95xx_priv *pdata = (struct smsc95xx_priv *)(dev->data[0]);
+	u32 hash_hi = 0;
+	u32 hash_lo = 0;
 	unsigned long flags;
 
-	pdata->hash_hi = 0;
-	pdata->hash_lo = 0;
-
 	spin_lock_irqsave(&pdata->mac_cr_lock, flags);
 
 	if (dev->net->flags & IFF_PROMISC) {
@@ -398,13 +399,13 @@ static void smsc95xx_set_multicast(struct net_device *netdev)
 			u32 bitnum = smsc95xx_hash(ha->addr);
 			u32 mask = 0x01 << (bitnum & 0x1F);
 			if (bitnum & 0x20)
-				pdata->hash_hi |= mask;
+				hash_hi |= mask;
 			else
-				pdata->hash_lo |= mask;
+				hash_lo |= mask;
 		}
 
 		netif_dbg(dev, drv, dev->net, "HASHH=0x%08X, HASHL=0x%08X\n",
-				   pdata->hash_hi, pdata->hash_lo);
+				   hash_hi, hash_lo);
 	} else {
 		netif_dbg(dev, drv, dev->net, "receive own packets only\n");
 		pdata->mac_cr &=
@@ -414,8 +415,8 @@ static void smsc95xx_set_multicast(struct net_device *netdev)
 	spin_unlock_irqrestore(&pdata->mac_cr_lock, flags);
 
 	/* Initiate async writes, as we can't wait for completion here */
-	smsc95xx_write_reg_async(dev, HASHH, &pdata->hash_hi);
-	smsc95xx_write_reg_async(dev, HASHL, &pdata->hash_lo);
+	smsc95xx_write_reg_async(dev, HASHH, &hash_hi);
+	smsc95xx_write_reg_async(dev, HASHL, &hash_lo);
 	smsc95xx_write_reg_async(dev, MAC_CR, &pdata->mac_cr);
 }
 
@@ -641,16 +642,57 @@ static int smsc95xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
 }
 
-static void smsc95xx_init_mac_address(struct usbnet *dev)
+/* Check the macaddr module parameter for a MAC address */
+static int smsc95xx_is_macaddr_param(struct usbnet *dev, u8 *dev_mac)
 {
-	struct usbnet_platform_data *pdata = dev->udev->dev.platform_data;
+	int i, j, got_num, num;
+	u8 mtbl[MAC_ADDR_LEN];
 
-	/*
-	 * if netdev platform data has taken responsibility for forcing
-	 * the MAC then nothing to do here
-	 */
+	if (macaddr[0] == ':')
+		return 0;
 
-	if (pdata && pdata->flags & USBNET_PLATDATA_FLAG__USE_MAC)
+	i = 0;
+	j = 0;
+	num = 0;
+	got_num = 0;
+	while (j < MAC_ADDR_LEN) {
+		if (macaddr[i] && macaddr[i] != ':') {
+			got_num++;
+			if ('0' <= macaddr[i] && macaddr[i] <= '9')
+				num = num * 16 + macaddr[i] - '0';
+			else if ('A' <= macaddr[i] && macaddr[i] <= 'F')
+				num = num * 16 + 10 + macaddr[i] - 'A';
+			else if ('a' <= macaddr[i] && macaddr[i] <= 'f')
+				num = num * 16 + 10 + macaddr[i] - 'a';
+			else
+				break;
+			i++;
+		} else if (got_num == 2) {
+			mtbl[j++] = (u8) num;
+			num = 0;
+			got_num = 0;
+			i++;
+		} else {
+			break;
+		}
+	}
+
+	if (j == MAC_ADDR_LEN) {
+		netif_dbg(dev, ifup, dev->net, "Overriding MAC address with: "
+		"%02x:%02x:%02x:%02x:%02x:%02x\n", mtbl[0], mtbl[1], mtbl[2],
+						mtbl[3], mtbl[4], mtbl[5]);
+		for (i = 0; i < MAC_ADDR_LEN; i++)
+			dev_mac[i] = mtbl[i];
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static void smsc95xx_init_mac_address(struct usbnet *dev)
+{
+	/* Check module parameters */
+	if (smsc95xx_is_macaddr_param(dev, dev->net->dev_addr))
 		return;
 
 	/* try reading mac address from EEPROM */
@@ -1177,8 +1219,9 @@ static int smsc95xx_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
 
 static u32 smsc95xx_calc_csum_preamble(struct sk_buff *skb)
 {
-	u16 low_16 = (u16)skb_checksum_start_offset(skb);
-	u16 high_16 = low_16 + skb->csum_offset;
+	int len = skb->data - skb->head;
+	u16 high_16 = (u16)(skb->csum_offset + skb->csum_start - len);
+	u16 low_16 = (u16)(skb->csum_start - len);
 	return (high_16 << 16) | low_16;
 }
 
@@ -1206,7 +1249,7 @@ static struct sk_buff *smsc95xx_tx_fixup(struct usbnet *dev,
 		if (skb->len <= 45) {
 			/* workaround - hardware tx checksum does not work
 			 * properly with extremely small packets */
-			long csstart = skb_checksum_start_offset(skb);
+			long csstart = skb->csum_start - skb_headroom(skb);
 			__wsum calc = csum_partial(skb->data + csstart,
 				skb->len - csstart, 0);
 			*((__sum16 *)(skb->data + csstart
-- 
1.7.5.4

