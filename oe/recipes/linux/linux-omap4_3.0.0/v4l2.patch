diff -urNP old/git/arch/arm/plat-omap/fb.c new/git/arch/arm/plat-omap/fb.c
--- old/git/arch/arm/plat-omap/fb.c	2011-10-24 09:42:59.000000000 +0200
+++ new/git/arch/arm/plat-omap/fb.c	2011-12-04 21:32:21.000000000 +0100
@@ -426,9 +426,24 @@
 
 #if defined(CONFIG_DRM_OMAP) || (CONFIG_DRM_OMAP_MODULE)
 
+static const int ovl_ids[] = {0};
+static const int mgr_ids[] = {0, 1, 2};
+static const char *dev_names[] = {"hdmi", "dvi"};
+static const struct omap_drm_platform_data pdata = {
+		.ovl_cnt = ARRAY_SIZE(ovl_ids),
+		.ovl_ids = ovl_ids,
+		.mgr_cnt = ARRAY_SIZE(mgr_ids),
+		.mgr_ids = mgr_ids,
+		.dev_cnt = ARRAY_SIZE(dev_names),
+		.dev_names = dev_names,
+};
+
 static struct platform_device omap_drm_device = {
 		.name = "omapdrm",
 		.id = 0,
+		.dev = {
+			.platform_data = (void *)&pdata,
+		}
 };
 
 static int __init omap_init_gpu(void)
diff -urNP old/git/drivers/media/video/omap/Kconfig new/git/drivers/media/video/omap/Kconfig
--- old/git/drivers/media/video/omap/Kconfig	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/Kconfig	2011-12-04 21:33:02.000000000 +0100
@@ -1,11 +1,14 @@
+config VIDEO_OMAP2_VOUT_VRFB
+	bool
+
 config VIDEO_OMAP2_VOUT
 	tristate "OMAP2/OMAP3 V4L2-Display driver"
-	depends on ARCH_OMAP2 || ARCH_OMAP3
+	depends on ARCH_OMAP2 || ARCH_OMAP3 || ARCH_OMAP4
 	select VIDEOBUF_GEN
 	select VIDEOBUF_DMA_CONTIG
 	select OMAP2_DSS
-	select OMAP2_VRAM
-	select OMAP2_VRFB
+	select OMAP2_VRFB if ARCH_OMAP2 || ARCH_OMAP3
+	select VIDEO_OMAP2_VOUT_VRFB if VIDEO_OMAP2_VOUT && OMAP2_VRFB
 	default n
 	---help---
 	  V4L2 Display driver support for OMAP2/3 based boards.
diff -urNP old/git/drivers/media/video/omap/Makefile new/git/drivers/media/video/omap/Makefile
--- old/git/drivers/media/video/omap/Makefile	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/Makefile	2011-12-04 21:33:02.000000000 +0100
@@ -4,4 +4,5 @@
 
 # OMAP2/3 Display driver
 omap-vout-y := omap_vout.o omap_voutlib.o
+omap-vout-$(CONFIG_VIDEO_OMAP2_VOUT_VRFB) += omap_vout_vrfb.o
 obj-$(CONFIG_VIDEO_OMAP2_VOUT) += omap-vout.o
diff -urNP old/git/drivers/media/video/omap/omap_vout.c new/git/drivers/media/video/omap/omap_vout.c
--- old/git/drivers/media/video/omap/omap_vout.c	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/omap_vout.c	2011-12-04 21:33:02.000000000 +0100
@@ -35,28 +35,23 @@
 #include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
 #include <linux/irq.h>
 #include <linux/videodev2.h>
-#include <linux/slab.h>
 
 #include <media/videobuf-dma-contig.h>
 #include <media/v4l2-device.h>
 #include <media/v4l2-ioctl.h>
 
-#include <plat/dma.h>
-#include <plat/vram.h>
-#include <plat/vrfb.h>
 #include <video/omapdss.h>
 
 #include "omap_voutlib.h"
 #include "omap_voutdef.h"
+#include "omap_vout_vrfb.h"
 
 MODULE_AUTHOR("Texas Instruments");
 MODULE_DESCRIPTION("OMAP Video for Linux Video out driver");
 MODULE_LICENSE("GPL");
 
-
 /* Driver Configuration macros */
 #define VOUT_NAME		"omap_vout"
 
@@ -65,31 +60,6 @@
 	OMAP_VIDEO2,
 };
 
-enum dma_channel_state {
-	DMA_CHAN_NOT_ALLOTED,
-	DMA_CHAN_ALLOTED,
-};
-
-#define QQVGA_WIDTH		160
-#define QQVGA_HEIGHT		120
-
-/* Max Resolution supported by the driver */
-#define VID_MAX_WIDTH		1280	/* Largest width */
-#define VID_MAX_HEIGHT		720	/* Largest height */
-
-/* Mimimum requirement is 2x2 for DSS */
-#define VID_MIN_WIDTH		2
-#define VID_MIN_HEIGHT		2
-
-/* 2048 x 2048 is max res supported by OMAP display controller */
-#define MAX_PIXELS_PER_LINE     2048
-
-#define VRFB_TX_TIMEOUT         1000
-#define VRFB_NUM_BUFS		4
-
-/* Max buffer size tobe allocated during init */
-#define OMAP_VOUT_MAX_BUF_SIZE (VID_MAX_WIDTH*VID_MAX_HEIGHT*4)
-
 static struct videobuf_queue_ops video_vbq_ops;
 /* Variables configurable through module params*/
 static u32 video1_numbuffers = 3;
@@ -125,8 +95,23 @@
 MODULE_PARM_DESC(vid2_static_vrfb_alloc,
 	"Static allocation of the VRFB buffer for video2 device");
 
-module_param(debug, bool, S_IRUGO);
-MODULE_PARM_DESC(debug, "Debug level (0-1)");
+module_param(debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "Debug level");
+
+
+#define VSYNC      (DISPC_IRQ_VSYNC | DISPC_IRQ_VSYNC2)
+#define IRQ_MASK  ((u32)(VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD))
+
+/* if we have TILER (OMAP44xx), then don't allocate buffers by
+ * default at startup.. it is unnecessary and rude..
+ */
+static inline int num_default_buffers(int vid)
+{
+	if (cpu_is_omap44xx())
+		return 0;
+	return (vid == OMAP_VIDEO1) ? video1_numbuffers : video2_numbuffers;
+}
+
 
 /* list of image formats supported by OMAP2 video pipelines */
 const static struct v4l2_fmtdesc omap_formats[] = {
@@ -167,89 +152,15 @@
 		.description = "UYVY, packed",
 		.pixelformat = V4L2_PIX_FMT_UYVY,
 	},
+	{
+		.description = "NV12 - YUV420 format",
+		.pixelformat = V4L2_PIX_FMT_NV12,
+	},
 };
 
 #define NUM_OUTPUT_FORMATS (ARRAY_SIZE(omap_formats))
 
 /*
- * Allocate buffers
- */
-static unsigned long omap_vout_alloc_buffer(u32 buf_size, u32 *phys_addr)
-{
-	u32 order, size;
-	unsigned long virt_addr, addr;
-
-	size = PAGE_ALIGN(buf_size);
-	order = get_order(size);
-	virt_addr = __get_free_pages(GFP_KERNEL | GFP_DMA, order);
-	addr = virt_addr;
-
-	if (virt_addr) {
-		while (size > 0) {
-			SetPageReserved(virt_to_page(addr));
-			addr += PAGE_SIZE;
-			size -= PAGE_SIZE;
-		}
-	}
-	*phys_addr = (u32) virt_to_phys((void *) virt_addr);
-	return virt_addr;
-}
-
-/*
- * Free buffers
- */
-static void omap_vout_free_buffer(unsigned long virtaddr, u32 buf_size)
-{
-	u32 order, size;
-	unsigned long addr = virtaddr;
-
-	size = PAGE_ALIGN(buf_size);
-	order = get_order(size);
-
-	while (size > 0) {
-		ClearPageReserved(virt_to_page(addr));
-		addr += PAGE_SIZE;
-		size -= PAGE_SIZE;
-	}
-	free_pages((unsigned long) virtaddr, order);
-}
-
-/*
- * Function for allocating video buffers
- */
-static int omap_vout_allocate_vrfb_buffers(struct omap_vout_device *vout,
-		unsigned int *count, int startindex)
-{
-	int i, j;
-
-	for (i = 0; i < *count; i++) {
-		if (!vout->smsshado_virt_addr[i]) {
-			vout->smsshado_virt_addr[i] =
-				omap_vout_alloc_buffer(vout->smsshado_size,
-						&vout->smsshado_phy_addr[i]);
-		}
-		if (!vout->smsshado_virt_addr[i] && startindex != -1) {
-			if (V4L2_MEMORY_MMAP == vout->memory && i >= startindex)
-				break;
-		}
-		if (!vout->smsshado_virt_addr[i]) {
-			for (j = 0; j < i; j++) {
-				omap_vout_free_buffer(
-						vout->smsshado_virt_addr[j],
-						vout->smsshado_size);
-				vout->smsshado_virt_addr[j] = 0;
-				vout->smsshado_phy_addr[j] = 0;
-			}
-			*count = 0;
-			return -ENOMEM;
-		}
-		memset((void *) vout->smsshado_virt_addr[i], 0,
-				vout->smsshado_size);
-	}
-	return 0;
-}
-
-/*
  * Try format
  */
 static int omap_vout_try_format(struct v4l2_pix_format *pix)
@@ -293,10 +204,22 @@
 		pix->colorspace = V4L2_COLORSPACE_SRGB;
 		bpp = RGB32_BPP;
 		break;
+	case V4L2_PIX_FMT_NV12:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		/* 1 byte per pixel in Y plane.. special handling needed in a
+		 * few places, which is a bit ugly..
+		 */
+		bpp = 1;
+		break;
 	}
+
 	pix->bytesperline = pix->width * bpp;
 	pix->sizeimage = pix->bytesperline * pix->height;
 
+	/* NV12 has additional half byte per pixel for UV */
+	if (V4L2_PIX_FMT_NV12 == pix->pixelformat)
+		pix->sizeimage += pix->sizeimage >> 1;
+
 	return bpp;
 }
 
@@ -342,138 +265,25 @@
 }
 
 /*
- * Wakes up the application once the DMA transfer to VRFB space is completed.
- */
-static void omap_vout_vrfb_dma_tx_callback(int lch, u16 ch_status, void *data)
-{
-	struct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;
-
-	t->tx_status = 1;
-	wake_up_interruptible(&t->wait);
-}
-
-/*
- * Release the VRFB context once the module exits
- */
-static void omap_vout_release_vrfb(struct omap_vout_device *vout)
-{
-	int i;
-
-	for (i = 0; i < VRFB_NUM_BUFS; i++)
-		omap_vrfb_release_ctx(&vout->vrfb_context[i]);
-
-	if (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {
-		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
-		omap_free_dma(vout->vrfb_dma_tx.dma_ch);
-	}
-}
-
-/*
- * Return true if rotation is 90 or 270
- */
-static inline int rotate_90_or_270(const struct omap_vout_device *vout)
-{
-	return (vout->rotation == dss_rotation_90_degree ||
-			vout->rotation == dss_rotation_270_degree);
-}
-
-/*
- * Return true if rotation is enabled
- */
-static inline int rotation_enabled(const struct omap_vout_device *vout)
-{
-	return vout->rotation || vout->mirror;
-}
-
-/*
- * Reverse the rotation degree if mirroring is enabled
- */
-static inline int calc_rotation(const struct omap_vout_device *vout)
-{
-	if (!vout->mirror)
-		return vout->rotation;
-
-	switch (vout->rotation) {
-	case dss_rotation_90_degree:
-		return dss_rotation_270_degree;
-	case dss_rotation_270_degree:
-		return dss_rotation_90_degree;
-	case dss_rotation_180_degree:
-		return dss_rotation_0_degree;
-	default:
-		return dss_rotation_180_degree;
-	}
-}
-
-/*
  * Free the V4L2 buffers
  */
-static void omap_vout_free_buffers(struct omap_vout_device *vout)
+void omap_vout_free_buffers(struct omap_vout_device *vout)
 {
 	int i, numbuffers;
 
-	/* Allocate memory for the buffers */
-	numbuffers = (vout->vid) ?  video2_numbuffers : video1_numbuffers;
+	/* Free memory for the buffers */
+	numbuffers = num_default_buffers(vout->vid);
 	vout->buffer_size = (vout->vid) ? video2_bufsize : video1_bufsize;
 
 	for (i = 0; i < numbuffers; i++) {
-		omap_vout_free_buffer(vout->buf_virt_addr[i],
-				vout->buffer_size);
-		vout->buf_phy_addr[i] = 0;
-		vout->buf_virt_addr[i] = 0;
+		omap_vout_free_buffer(&vout->buf[i]);
 	}
 }
 
 /*
- * Free VRFB buffers
- */
-static void omap_vout_free_vrfb_buffers(struct omap_vout_device *vout)
-{
-	int j;
-
-	for (j = 0; j < VRFB_NUM_BUFS; j++) {
-		omap_vout_free_buffer(vout->smsshado_virt_addr[j],
-				vout->smsshado_size);
-		vout->smsshado_virt_addr[j] = 0;
-		vout->smsshado_phy_addr[j] = 0;
-	}
-}
-
-/*
- * Allocate the buffers for the VRFB space.  Data is copied from V4L2
- * buffers to the VRFB buffers using the DMA engine.
- */
-static int omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,
-			  unsigned int *count, unsigned int startindex)
-{
-	int i;
-	bool yuv_mode;
-
-	/* Allocate the VRFB buffers only if the buffers are not
-	 * allocated during init time.
-	 */
-	if ((rotation_enabled(vout)) && !vout->vrfb_static_allocation)
-		if (omap_vout_allocate_vrfb_buffers(vout, count, startindex))
-			return -ENOMEM;
-
-	if (vout->dss_mode == OMAP_DSS_COLOR_YUV2 ||
-			vout->dss_mode == OMAP_DSS_COLOR_UYVY)
-		yuv_mode = true;
-	else
-		yuv_mode = false;
-
-	for (i = 0; i < *count; i++)
-		omap_vrfb_setup(&vout->vrfb_context[i],
-				vout->smsshado_phy_addr[i], vout->pix.width,
-				vout->pix.height, vout->bpp, yuv_mode);
-
-	return 0;
-}
-
-/*
  * Convert V4L2 rotation to DSS rotation
  *	V4L2 understand 0, 90, 180, 270.
- *	Convert to 0, 1, 2 and 3 respectively for DSS
+ *	Convert to 0, 1, 2 and 3 repsectively for DSS
  */
 static int v4l2_rot_to_dss_rot(int v4l2_rotation,
 			enum dss_rotation *rotation, bool mirror)
@@ -499,124 +309,45 @@
 	return ret;
 }
 
-/*
- * Calculate the buffer offsets from which the streaming should
- * start. This offset calculation is mainly required because of
- * the VRFB 32 pixels alignment with rotation.
- */
 static int omap_vout_calculate_offset(struct omap_vout_device *vout)
 {
-	struct omap_overlay *ovl;
-	enum dss_rotation rotation;
 	struct omapvideo_info *ovid;
-	bool mirroring = vout->mirror;
-	struct omap_dss_device *cur_display;
 	struct v4l2_rect *crop = &vout->crop;
 	struct v4l2_pix_format *pix = &vout->pix;
 	int *cropped_offset = &vout->cropped_offset;
-	int vr_ps = 1, ps = 2, temp_ps = 2;
-	int offset = 0, ctop = 0, cleft = 0, line_length = 0;
+	int ps = 2, line_length = 0;
+	u32 *cropped_uv_offset = &vout->cropped_uv_offset;
 
 	ovid = &vout->vid_info;
-	ovl = ovid->overlays[0];
-	/* get the display device attached to the overlay */
-	if (!ovl->manager || !ovl->manager->device)
-		return -1;
 
-	cur_display = ovl->manager->device;
-	rotation = calc_rotation(vout);
+	if (ovid->rotation_type == VOUT_ROT_VRFB) {
+		omap_vout_calculate_vrfb_offset(vout);
+	} else {
+		vout->line_length = line_length = pix->width;
 
-	if (V4L2_PIX_FMT_YUYV == pix->pixelformat ||
-			V4L2_PIX_FMT_UYVY == pix->pixelformat) {
-		if (rotation_enabled(vout)) {
-			/*
-			 * ps    - Actual pixel size for YUYV/UYVY for
-			 *         VRFB/Mirroring is 4 bytes
-			 * vr_ps - Virtually pixel size for YUYV/UYVY is
-			 *         2 bytes
-			 */
+		if (V4L2_PIX_FMT_YUYV == pix->pixelformat ||
+			V4L2_PIX_FMT_UYVY == pix->pixelformat)
+			ps = 2;
+		else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat)
 			ps = 4;
-			vr_ps = 2;
-		} else {
-			ps = 2;	/* otherwise the pixel size is 2 byte */
-		}
-	} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {
-		ps = 4;
-	} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {
-		ps = 3;
-	}
-	vout->ps = ps;
-	vout->vr_ps = vr_ps;
-
-	if (rotation_enabled(vout)) {
-		line_length = MAX_PIXELS_PER_LINE;
-		ctop = (pix->height - crop->height) - crop->top;
-		cleft = (pix->width - crop->width) - crop->left;
-	} else {
-		line_length = pix->width;
+		else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat)
+			ps = 3;
+		else if (V4L2_PIX_FMT_NV12 == pix->pixelformat)
+			ps = 1;
+
+		vout->ps = ps;
+
+		*cropped_offset = (line_length * ps) *
+			crop->top + crop->left * ps;
+
+		if (V4L2_PIX_FMT_NV12 == pix->pixelformat)
+			*cropped_uv_offset = (line_length * ps) *
+				(crop->top >> 1) + (crop->left & ~1) * ps;
 	}
-	vout->line_length = line_length;
-	switch (rotation) {
-	case dss_rotation_90_degree:
-		offset = vout->vrfb_context[0].yoffset *
-			vout->vrfb_context[0].bytespp;
-		temp_ps = ps / vr_ps;
-		if (mirroring == 0) {
-			*cropped_offset = offset + line_length *
-				temp_ps * cleft + crop->top * temp_ps;
-		} else {
-			*cropped_offset = offset + line_length * temp_ps *
-				cleft + crop->top * temp_ps + (line_length *
-				((crop->width / (vr_ps)) - 1) * ps);
-		}
-		break;
-	case dss_rotation_180_degree:
-		offset = ((MAX_PIXELS_PER_LINE * vout->vrfb_context[0].yoffset *
-			vout->vrfb_context[0].bytespp) +
-			(vout->vrfb_context[0].xoffset *
-			vout->vrfb_context[0].bytespp));
-		if (mirroring == 0) {
-			*cropped_offset = offset + (line_length * ps * ctop) +
-				(cleft / vr_ps) * ps;
 
-		} else {
-			*cropped_offset = offset + (line_length * ps * ctop) +
-				(cleft / vr_ps) * ps + (line_length *
-				(crop->height - 1) * ps);
-		}
-		break;
-	case dss_rotation_270_degree:
-		offset = MAX_PIXELS_PER_LINE * vout->vrfb_context[0].xoffset *
-			vout->vrfb_context[0].bytespp;
-		temp_ps = ps / vr_ps;
-		if (mirroring == 0) {
-			*cropped_offset = offset + line_length *
-			    temp_ps * crop->left + ctop * ps;
-		} else {
-			*cropped_offset = offset + line_length *
-				temp_ps * crop->left + ctop * ps +
-				(line_length * ((crop->width / vr_ps) - 1) *
-				 ps);
-		}
-		break;
-	case dss_rotation_0_degree:
-		if (mirroring == 0) {
-			*cropped_offset = (line_length * ps) *
-				crop->top + (crop->left / vr_ps) * ps;
-		} else {
-			*cropped_offset = (line_length * ps) *
-				crop->top + (crop->left / vr_ps) * ps +
-				(line_length * (crop->height - 1) * ps);
-		}
-		break;
-	default:
-		*cropped_offset = (line_length * ps * crop->top) /
-			vr_ps + (crop->left * ps) / vr_ps +
-			((crop->width / vr_ps) - 1) * ps;
-		break;
-	}
 	v4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "%s Offset:%x\n",
-			__func__, *cropped_offset);
+			__func__, vout->cropped_offset);
+
 	return 0;
 }
 
@@ -635,6 +366,7 @@
 
 	switch (pix->pixelformat) {
 	case 0:
+		mode = -EINVAL;
 		break;
 	case V4L2_PIX_FMT_YUYV:
 		mode = OMAP_DSS_COLOR_YUV2;
@@ -655,6 +387,9 @@
 	case V4L2_PIX_FMT_BGR32:
 		mode = OMAP_DSS_COLOR_RGBX32;
 		break;
+	case V4L2_PIX_FMT_NV12:
+		mode = OMAP_DSS_COLOR_NV12;
+		break;
 	default:
 		mode = -EINVAL;
 	}
@@ -666,7 +401,7 @@
  */
 int omapvid_setup_overlay(struct omap_vout_device *vout,
 		struct omap_overlay *ovl, int posx, int posy, int outw,
-		int outh, u32 addr)
+		int outh, u32 addr, u32 uv_addr)
 {
 	int ret = 0;
 	struct omap_overlay_info info;
@@ -700,7 +435,15 @@
 	}
 
 	ovl->get_overlay_info(ovl, &info);
-	info.paddr = addr;
+
+	if (addr)
+		info.paddr = addr;
+
+	if (OMAP_DSS_COLOR_NV12 == vout->dss_mode)
+		info.p_uv_addr = uv_addr;
+	else
+		info.p_uv_addr = (u32) NULL;
+
 	info.vaddr = NULL;
 	info.width = cropwidth;
 	info.height = cropheight;
@@ -730,6 +473,9 @@
 		info.pos_y, info.out_width, info.out_height, info.rotation_type,
 		info.screen_width);
 
+	v4l2_dbg(1, debug, &vout->vid_dev->v4l2_dev, "info.puvaddr=%x\n",
+		info.p_uv_addr);
+
 	ret = ovl->set_overlay_info(ovl, &info);
 	if (ret)
 		goto setup_ovl_err;
@@ -744,7 +490,7 @@
 /*
  * Initialize the overlay structure
  */
-int omapvid_init(struct omap_vout_device *vout, u32 addr)
+int omapvid_init(struct omap_vout_device *vout, u32 addr, u32 uv_addr)
 {
 	int ret = 0, i;
 	struct v4l2_window *win;
@@ -795,7 +541,7 @@
 		}
 
 		ret = omapvid_setup_overlay(vout, ovl, posx, posy,
-				outw, outh, addr);
+				outw, outh, addr, uv_addr);
 		if (ret)
 			goto omapvid_init_err;
 	}
@@ -825,47 +571,11 @@
 	return 0;
 }
 
-static int _program_cur(struct omap_vout_device *vout)
-{
-	int ret;
-	u32 addr = (unsigned long) vout->queued_buf_addr[vout->cur_frm->i]
-			+ vout->cropped_offset;
-
-	/* First save the configuration in ovelray structure */
-	ret = omapvid_init(vout, addr);
-	if (ret) {
-		printk(KERN_ERR VOUT_NAME
-				"failed to set overlay info\n");
-		return ret;
-	}
-	/* Enable the pipeline and set the Go bit */
-	ret = omapvid_apply_changes(vout);
-	if (ret)
-		printk(KERN_ERR VOUT_NAME
-				"failed to change mode\n");
-
-	return ret;
-}
-
-static struct videobuf_buffer * _get_next_frm(struct omap_vout_device *vout)
-{
-	struct videobuf_buffer *frm;
-
-	if (list_empty(&vout->dma_queue))
-		return NULL;
-
-	frm = list_entry(vout->dma_queue.next,
-			struct videobuf_buffer, queue);
-
-	list_del(&frm->queue);
-
-	return frm;
-}
-
 void omap_vout_isr(void *arg, unsigned int irqstatus)
 {
 	int ret;
 	u32 addr, fid;
+	u32 uv_addr;
 	struct omap_overlay *ovl;
 	struct timeval timevalue;
 	struct omapvideo_info *ovid;
@@ -886,7 +596,7 @@
 	spin_lock(&vout->vbq_lock);
 	do_gettimeofday(&timevalue);
 	if (cur_display->type == OMAP_DISPLAY_TYPE_DPI) {
-		if (!(irqstatus & DISPC_IRQ_VSYNC))
+		if (!(irqstatus & VSYNC))
 			goto vout_isr_err;
 
 		if (!vout->first_int && (vout->cur_frm != vout->next_frm)) {
@@ -908,8 +618,11 @@
 		addr = (unsigned long) vout->queued_buf_addr[vout->next_frm->i]
 			+ vout->cropped_offset;
 
+		uv_addr = (unsigned long)vout->queued_buf_uv_addr[vout->next_frm->i]
+			+ vout->cropped_uv_offset;
+
 		/* First save the configuration in ovelray structure */
-		ret = omapvid_init(vout, addr);
+		ret = omapvid_init(vout, addr, uv_addr);
 		if (ret)
 			printk(KERN_ERR VOUT_NAME
 					"failed to set overlay info\n");
@@ -918,11 +631,6 @@
 		if (ret)
 			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
 	} else {
-
-		if (vout->first_int) {
-			vout->first_int = 0;
-			goto vout_isr_err;
-		}
 		if (irqstatus & DISPC_IRQ_EVSYNC_ODD)
 			fid = 1;
 		else if (irqstatus & DISPC_IRQ_EVSYNC_EVEN)
@@ -930,19 +638,37 @@
 		else
 			goto vout_isr_err;
 
-		vout->field_id ^= 1;
-		if (0 == fid) {
-			if (vout->cur_frm) {
-				vout->cur_frm->ts = timevalue;
-				vout->cur_frm->state = VIDEOBUF_DONE;
-				wake_up_interruptible(&vout->cur_frm->done);
-			}
+		if (!vout->first_int && (vout->cur_frm != vout->next_frm)) {
+			vout->cur_frm->ts = timevalue;
+			vout->cur_frm->state = VIDEOBUF_DONE;
+			wake_up_interruptible(&vout->cur_frm->done);
+			vout->cur_frm = vout->next_frm;
 		}
-		vout->cur_frm = _get_next_frm(vout);
-		if (!vout->cur_frm)
+		vout->first_int = 0;
+		if (list_empty(&vout->dma_queue))
 			goto vout_isr_err;
-		vout->cur_frm->state = VIDEOBUF_ACTIVE;
-		_program_cur(vout);
+
+		vout->next_frm = list_entry(vout->dma_queue.next,
+				struct videobuf_buffer, queue);
+		list_del(&vout->next_frm->queue);
+
+		vout->next_frm->state = VIDEOBUF_ACTIVE;
+
+		addr = (unsigned long) vout->queued_buf_addr[vout->next_frm->i]
+			+ vout->cropped_offset;
+
+		uv_addr = (unsigned long)vout->queued_buf_uv_addr[vout->next_frm->i]
+			+ vout->cropped_uv_offset;
+
+		/* First save the configuration in ovelray structure */
+		ret = omapvid_init(vout, addr, uv_addr);
+		if (ret)
+			printk(KERN_ERR VOUT_NAME
+					"failed to set overlay info\n");
+		/* Enable the pipeline and set the Go bit */
+		ret = omapvid_apply_changes(vout);
+		if (ret)
+			printk(KERN_ERR VOUT_NAME "failed to change mode\n");
 	}
 
 vout_isr_err:
@@ -962,8 +688,8 @@
 			  unsigned int *size)
 {
 	int startindex = 0, i, j;
-	u32 phy_addr = 0, virt_addr = 0;
 	struct omap_vout_device *vout = q->priv_data;
+	struct omapvideo_info *ovid = &vout->vid_info;
 
 	if (!vout)
 		return -EINVAL;
@@ -971,54 +697,42 @@
 	if (V4L2_BUF_TYPE_VIDEO_OUTPUT != q->type)
 		return -EINVAL;
 
-	startindex = (vout->vid == OMAP_VIDEO1) ?
-		video1_numbuffers : video2_numbuffers;
+	startindex = num_default_buffers(vout->vid);
 	if (V4L2_MEMORY_MMAP == vout->memory && *count < startindex)
 		*count = startindex;
 
-	if ((rotation_enabled(vout)) && *count > VRFB_NUM_BUFS)
-		*count = VRFB_NUM_BUFS;
-
-	/* If rotation is enabled, allocate memory for VRFB space also */
-	if (rotation_enabled(vout))
+	if (ovid->rotation_type == VOUT_ROT_VRFB) {
 		if (omap_vout_vrfb_buffer_setup(vout, count, startindex))
 			return -ENOMEM;
+	}
 
 	if (V4L2_MEMORY_MMAP != vout->memory)
 		return 0;
 
-	/* Now allocated the V4L2 buffers */
-	*size = PAGE_ALIGN(vout->pix.width * vout->pix.height * vout->bpp);
-	startindex = (vout->vid == OMAP_VIDEO1) ?
-		video1_numbuffers : video2_numbuffers;
-
-	/* Check the size of the buffer */
-	if (*size > vout->buffer_size) {
-		v4l2_err(&vout->vid_dev->v4l2_dev,
-				"buffer allocation mismatch [%u] [%u]\n",
-				*size, vout->buffer_size);
-		return -ENOMEM;
-	}
+	/* Now allocate the V4L2 buffers */
+	if (V4L2_PIX_FMT_NV12 == vout->pix.pixelformat)
+		*size = PAGE_ALIGN(vout->pix.width * vout->pix.height * vout->bpp * 3/2);
+	else
+		*size = PAGE_ALIGN(vout->pix.width * vout->pix.height * vout->bpp);
 
 	for (i = startindex; i < *count; i++) {
 		vout->buffer_size = *size;
 
-		virt_addr = omap_vout_alloc_buffer(vout->buffer_size,
-				&phy_addr);
-		if (!virt_addr) {
-			if (!rotation_enabled(vout))
+		if (omap_vout_alloc_buffer(&vout->buf[i], vout->buffer_size)) {
+			if (ovid->rotation_type == VOUT_ROT_NONE) {
 				break;
-			/* Free the VRFB buffers if no space for V4L2 buffers */
-			for (j = i; j < *count; j++) {
-				omap_vout_free_buffer(
-						vout->smsshado_virt_addr[j],
-						vout->smsshado_size);
-				vout->smsshado_virt_addr[j] = 0;
-				vout->smsshado_phy_addr[j] = 0;
+			} else {
+				if (!rotation_enabled(vout))
+					break;
+				/* Free the VRFB buffers if no space for V4L2 buffers */
+				for (j = i; j < *count; j++)
+					omap_vout_free_buffer(&vout->smsshado[j]);
+				// XXX there should really be a break or i-- here..  I'm not
+				// entirely sure the original intent.  Clean up all buffers
+				// or free VRFB buffers in attempt to allocate more v4l2
+				// buffers.  So this logic here is suspect!
 			}
 		}
-		vout->buf_virt_addr[i] = virt_addr;
-		vout->buf_phy_addr[i] = phy_addr;
 	}
 	*count = vout->buffer_allocated = i;
 
@@ -1027,36 +741,16 @@
 
 /*
  * Free the V4L2 buffers additionally allocated than default
- * number of buffers and free all the VRFB buffers
+ * number of buffers
  */
-static void omap_vout_free_allbuffers(struct omap_vout_device *vout)
+static void omap_vout_free_extra_buffers(struct omap_vout_device *vout)
 {
 	int num_buffers = 0, i;
 
-	num_buffers = (vout->vid == OMAP_VIDEO1) ?
-		video1_numbuffers : video2_numbuffers;
+	num_buffers = num_default_buffers(vout->vid);
 
 	for (i = num_buffers; i < vout->buffer_allocated; i++) {
-		if (vout->buf_virt_addr[i])
-			omap_vout_free_buffer(vout->buf_virt_addr[i],
-					vout->buffer_size);
-
-		vout->buf_virt_addr[i] = 0;
-		vout->buf_phy_addr[i] = 0;
-	}
-	/* Free the VRFB buffers only if they are allocated
-	 * during reqbufs.  Don't free if init time allocated
-	 */
-	if (!vout->vrfb_static_allocation) {
-		for (i = 0; i < VRFB_NUM_BUFS; i++) {
-			if (vout->smsshado_virt_addr[i]) {
-				omap_vout_free_buffer(
-						vout->smsshado_virt_addr[i],
-						vout->smsshado_size);
-				vout->smsshado_virt_addr[i] = 0;
-				vout->smsshado_phy_addr[i] = 0;
-			}
-		}
+		omap_vout_free_buffer(&vout->buf[i]);
 	}
 	vout->buffer_allocated = num_buffers;
 }
@@ -1069,21 +763,19 @@
  * buffer into VRFB memory space before giving it to the DSS.
  */
 static int omap_vout_buffer_prepare(struct videobuf_queue *q,
-			    struct videobuf_buffer *vb,
-			    enum v4l2_field field)
+			struct videobuf_buffer *vb,
+			enum v4l2_field field)
 {
-	dma_addr_t dmabuf;
-	struct vid_vrfb_dma *tx;
-	enum dss_rotation rotation;
 	struct omap_vout_device *vout = q->priv_data;
-	u32 dest_frame_index = 0, src_element_index = 0;
-	u32 dest_element_index = 0, src_frame_index = 0;
-	u32 elem_count = 0, frame_count = 0, pixsize = 2;
+	struct omapvideo_info *ovid = &vout->vid_info;
+	unsigned long ysize = vout->pix.width * vout->pix.height * vout->bpp;
 
 	if (VIDEOBUF_NEEDS_INIT == vb->state) {
 		vb->width = vout->pix.width;
 		vb->height = vout->pix.height;
 		vb->size = vb->width * vb->height * vout->bpp;
+		if (V4L2_PIX_FMT_NV12 == vout->pix.pixelformat)
+			vb->size = vb->size * 3 / 2;
 		vb->field = field;
 	}
 	vb->state = VIDEOBUF_PREPARED;
@@ -1096,71 +788,22 @@
 		/* Physical address */
 		vout->queued_buf_addr[vb->i] = (u8 *)
 			omap_vout_uservirt_to_phys(vb->baddr);
+		vout->queued_buf_uv_addr[vb->i] = (u8 *)
+			omap_vout_uservirt_to_phys(vb->baddr + ysize);
 	} else {
-		vout->queued_buf_addr[vb->i] = (u8 *)vout->buf_phy_addr[vb->i];
+		vout->queued_buf_addr[vb->i] = (u8 *) vout->buf[vb->i].paddr;
+		vout->queued_buf_uv_addr[vb->i] =
+				(u8 *) (vout->buf[vb->i].paddr + ysize);
 	}
 
-	if (!rotation_enabled(vout))
+	if (ovid->rotation_type == VOUT_ROT_VRFB)
+		return omap_vout_prepare_vrfb(vout, vb);
+	else
 		return 0;
-
-	dmabuf = vout->buf_phy_addr[vb->i];
-	/* If rotation is enabled, copy input buffer into VRFB
-	 * memory space using DMA. We are copying input buffer
-	 * into VRFB memory space of desired angle and DSS will
-	 * read image VRFB memory for 0 degree angle
-	 */
-	pixsize = vout->bpp * vout->vrfb_bpp;
-	/*
-	 * DMA transfer in double index mode
-	 */
-
-	/* Frame index */
-	dest_frame_index = ((MAX_PIXELS_PER_LINE * pixsize) -
-			(vout->pix.width * vout->bpp)) + 1;
-
-	/* Source and destination parameters */
-	src_element_index = 0;
-	src_frame_index = 0;
-	dest_element_index = 1;
-	/* Number of elements per frame */
-	elem_count = vout->pix.width * vout->bpp;
-	frame_count = vout->pix.height;
-	tx = &vout->vrfb_dma_tx;
-	tx->tx_status = 0;
-	omap_set_dma_transfer_params(tx->dma_ch, OMAP_DMA_DATA_TYPE_S32,
-			(elem_count / 4), frame_count, OMAP_DMA_SYNC_ELEMENT,
-			tx->dev_id, 0x0);
-	/* src_port required only for OMAP1 */
-	omap_set_dma_src_params(tx->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
-			dmabuf, src_element_index, src_frame_index);
-	/*set dma source burst mode for VRFB */
-	omap_set_dma_src_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);
-	rotation = calc_rotation(vout);
-
-	/* dest_port required only for OMAP1 */
-	omap_set_dma_dest_params(tx->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
-			vout->vrfb_context[vb->i].paddr[0], dest_element_index,
-			dest_frame_index);
-	/*set dma dest burst mode for VRFB */
-	omap_set_dma_dest_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);
-	omap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);
-
-	omap_start_dma(tx->dma_ch);
-	interruptible_sleep_on_timeout(&tx->wait, VRFB_TX_TIMEOUT);
-
-	if (tx->tx_status == 0) {
-		omap_stop_dma(tx->dma_ch);
-		return -EINVAL;
-	}
-	/* Store buffers physical address into an array. Addresses
-	 * from this array will be used to configure DSS */
-	vout->queued_buf_addr[vb->i] = (u8 *)
-		vout->vrfb_context[vb->i].paddr[rotation];
-	return 0;
 }
 
 /*
- * Buffer queue function will be called from the videobuf layer when _QBUF
+ * Buffer queue funtion will be called from the videobuf layer when _QBUF
  * ioctl is called. It is used to enqueue buffer, which is ready to be
  * displayed.
  */
@@ -1220,7 +863,7 @@
 static int omap_vout_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	int i;
-	void *pos;
+	unsigned long paddr;
 	unsigned long start = vma->vm_start;
 	unsigned long size = (vma->vm_end - vma->vm_start);
 	struct omap_vout_device *vout = file->private_data;
@@ -1246,29 +889,21 @@
 				(vma->vm_pgoff << PAGE_SHIFT));
 		return -EINVAL;
 	}
-	/* Check the size of the buffer */
-	if (size > vout->buffer_size) {
-		v4l2_err(&vout->vid_dev->v4l2_dev,
-				"insufficient memory [%lu] [%u]\n",
-				size, vout->buffer_size);
-		return -ENOMEM;
-	}
-
 	q->bufs[i]->baddr = vma->vm_start;
 
 	vma->vm_flags |= VM_RESERVED;
 	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 	vma->vm_ops = &omap_vout_vm_ops;
 	vma->vm_private_data = (void *) vout;
-	pos = (void *)vout->buf_virt_addr[i];
-	vma->vm_pgoff = virt_to_phys((void *)pos) >> PAGE_SHIFT;
+	paddr = vout->buf[i].paddr;
+	vma->vm_pgoff = paddr >> PAGE_SHIFT;
 	while (size > 0) {
 		unsigned long pfn;
-		pfn = virt_to_phys((void *) pos) >> PAGE_SHIFT;
-		if (remap_pfn_range(vma, start, pfn, PAGE_SIZE, PAGE_SHARED))
+		pfn = paddr >> PAGE_SHIFT;
+		if (remap_pfn_range(vma, start, pfn, PAGE_SIZE, vma->vm_page_prot))
 			return -EAGAIN;
 		start += PAGE_SIZE;
-		pos += PAGE_SIZE;
+		paddr += PAGE_SIZE;
 		size -= PAGE_SIZE;
 	}
 	vout->mmap_count++;
@@ -1308,17 +943,21 @@
 				"Unable to apply changes\n");
 
 	/* Free all buffers */
-	omap_vout_free_allbuffers(vout);
+	omap_vout_free_extra_buffers(vout);
+
+	/* Free the VRFB buffers only if they are allocated
+	 * during reqbufs.  Don't free if init time allocated
+	 */
+	if (ovid->rotation_type == VOUT_ROT_VRFB) {
+		if (!vout->vrfb_static_allocation)
+			omap_vout_free_vrfb_buffers(vout);
+	}
 	videobuf_mmap_free(q);
 
 	/* Even if apply changes fails we should continue
 	   freeing allocated memory */
 	if (vout->streaming) {
-		u32 mask = 0;
-
-		mask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN |
-			DISPC_IRQ_EVSYNC_ODD;
-		omap_dispc_unregister_isr(omap_vout_isr, vout, mask);
+		omap_dispc_unregister_isr(omap_vout_isr, vout, IRQ_MASK);
 		vout->streaming = 0;
 
 		videobuf_streamoff(q);
@@ -1487,6 +1126,8 @@
 
 	bpp = omap_vout_try_format(&f->fmt.pix);
 	f->fmt.pix.sizeimage = f->fmt.pix.width * f->fmt.pix.height * bpp;
+	if (V4L2_PIX_FMT_NV12 == f->fmt.pix.pixelformat)
+		f->fmt.pix.sizeimage += f->fmt.pix.sizeimage >> 1;
 
 	/* try & set the new output format */
 	vout->bpp = bpp;
@@ -1502,7 +1143,7 @@
 	omap_vout_new_format(&vout->pix, &vout->fbuf, &vout->crop, &vout->win);
 
 	/* Save the changes in the overlay strcuture */
-	ret = omapvid_init(vout, 0);
+	ret = omapvid_init(vout, 0, 0);
 	if (ret) {
 		v4l2_err(&vout->vid_dev->v4l2_dev, "failed to change mode\n");
 		goto s_fmt_vid_out_exit;
@@ -1641,9 +1282,6 @@
 	struct omap_overlay *ovl;
 	struct omap_video_timings *timing;
 
-	if (vout->streaming)
-		return -EBUSY;
-
 	mutex_lock(&vout->lock);
 	ovid = &vout->vid_info;
 	ovl = ovid->overlays[0];
@@ -1667,6 +1305,11 @@
 		ret = omap_vout_new_crop(&vout->pix, &vout->crop, &vout->win,
 				&vout->fbuf, &crop->c);
 
+	if (vout->streaming) {
+		if (omap_vout_calculate_offset(vout))
+			return -EINVAL;
+	}
+
 s_crop_err:
 	mutex_unlock(&vout->lock);
 	return ret;
@@ -1735,9 +1378,17 @@
 	switch (a->id) {
 	case V4L2_CID_ROTATE:
 	{
+		struct omapvideo_info *ovid;
 		int rotation = a->value;
 
+		ovid = &vout->vid_info;
+
 		mutex_lock(&vout->lock);
+		if (rotation && ovid->rotation_type == VOUT_ROT_NONE) {
+			mutex_unlock(&vout->lock);
+			ret = -ERANGE;
+			break;
+		}
 
 		if (rotation && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {
 			mutex_unlock(&vout->lock);
@@ -1793,6 +1444,11 @@
 		ovl = ovid->overlays[0];
 
 		mutex_lock(&vout->lock);
+		if (mirror && ovid->rotation_type == VOUT_ROT_NONE) {
+			mutex_unlock(&vout->lock);
+			ret = -ERANGE;
+			break;
+		}
 
 		if (mirror  && vout->pix.pixelformat == V4L2_PIX_FMT_RGB24) {
 			mutex_unlock(&vout->lock);
@@ -1839,13 +1495,9 @@
 			ret = -EBUSY;
 			goto reqbuf_err;
 		}
-		num_buffers = (vout->vid == OMAP_VIDEO1) ?
-			video1_numbuffers : video2_numbuffers;
+		num_buffers = num_default_buffers(vout->vid);
 		for (i = num_buffers; i < vout->buffer_allocated; i++) {
-			omap_vout_free_buffer(vout->buf_virt_addr[i],
-					vout->buffer_size);
-			vout->buf_virt_addr[i] = 0;
-			vout->buf_phy_addr[i] = 0;
+			omap_vout_free_buffer(&vout->buf[i]);
 		}
 		vout->buffer_allocated = num_buffers;
 		videobuf_mmap_free(q);
@@ -1929,10 +1581,43 @@
 		return videobuf_dqbuf(q, (struct v4l2_buffer *)b, 0);
 }
 
+static bool is_connected(struct omap_overlay_manager *mgr)
+{
+	if (mgr && mgr->device && mgr->device->driver) {
+		struct omap_dss_device *dssdev = mgr->device;
+		struct omap_dss_driver *dssdrv = dssdev->driver;
+		/* if driver doesn't implement is_detected(), then assume
+		 * it is a permanently connected device (like an LCD panel)
+		 * as opposed to a pluggable device (like HDMI or DVI)
+		 */
+		if (dssdrv->is_detected && !dssdrv->is_detected(dssdev, false))
+			return false;
+		return true;
+	}
+	return false;
+}
+
+static void ensure_ovl_connected(struct omap_overlay *ovl)
+{
+	if (!is_connected(ovl->manager)) {
+		int i;
+		ovl->unset_manager(ovl);
+		for (i = 0; i < omap_dss_get_num_overlay_managers(); i++) {
+			struct omap_overlay_manager *mgr =
+					omap_dss_get_overlay_manager(i);
+			if (is_connected(mgr)) {
+				ovl->set_manager(ovl, mgr);
+				return;
+			}
+		}
+	}
+}
+
 static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
 {
 	int ret = 0, j;
-	u32 addr = 0, mask = 0;
+	u32 addr = 0;
+	u32 uv_addr = 0;
 	struct omap_vout_device *vout = fh;
 	struct videobuf_queue *q = &vout->vbq;
 	struct omapvideo_info *ovid = &vout->vid_info;
@@ -1948,12 +1633,16 @@
 	if (ret)
 		goto streamon_err;
 
-	/* Get the next frame from the buffer queue */
-	vout->cur_frm = _get_next_frm(vout);
-	if (!vout->cur_frm) {
+	if (list_empty(&vout->dma_queue)) {
 		ret = -EIO;
 		goto streamon_err1;
 	}
+
+	/* Get the next frame from the buffer queue */
+	vout->next_frm = vout->cur_frm = list_entry(vout->dma_queue.next,
+			struct videobuf_buffer, queue);
+	/* Remove buffer from the buffer queue */
+	list_del(&vout->cur_frm->queue);
 	/* Mark state of the current frame to active */
 	vout->cur_frm->state = VIDEOBUF_ACTIVE;
 	/* Initialize field_id and started member */
@@ -1970,19 +1659,22 @@
 	}
 	addr = (unsigned long) vout->queued_buf_addr[vout->cur_frm->i]
 		+ vout->cropped_offset;
+	uv_addr = (unsigned long) vout->queued_buf_uv_addr[vout->cur_frm->i]
+		+ vout->cropped_uv_offset;
 
-	mask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD;
-
-	omap_dispc_register_isr(omap_vout_isr, vout, mask);
+	omap_dispc_register_isr(omap_vout_isr, vout, IRQ_MASK);
 
 	for (j = 0; j < ovid->num_overlays; j++) {
 		struct omap_overlay *ovl = ovid->overlays[j];
 
+		ensure_ovl_connected(ovl);
+
 		if (ovl->manager && ovl->manager->device) {
 			struct omap_overlay_info info;
 			ovl->get_overlay_info(ovl, &info);
 			info.enabled = 1;
 			info.paddr = addr;
+			info.p_uv_addr = uv_addr;
 			if (ovl->set_overlay_info(ovl, &info)) {
 				ret = -EINVAL;
 				goto streamon_err1;
@@ -1990,8 +1682,8 @@
 		}
 	}
 
-	/* First save the configuration in ovelray structure */
-	ret = omapvid_init(vout, addr);
+	/* First save the configuration in overlay structure */
+	ret = omapvid_init(vout, addr, uv_addr);
 	if (ret)
 		v4l2_err(&vout->vid_dev->v4l2_dev,
 				"failed to set overlay info\n");
@@ -2012,7 +1704,6 @@
 
 static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
 {
-	u32 mask = 0;
 	int ret = 0, j;
 	struct omap_vout_device *vout = fh;
 	struct omapvideo_info *ovid = &vout->vid_info;
@@ -2021,9 +1712,8 @@
 		return -EINVAL;
 
 	vout->streaming = 0;
-	mask = DISPC_IRQ_VSYNC | DISPC_IRQ_EVSYNC_EVEN | DISPC_IRQ_EVSYNC_ODD;
 
-	omap_dispc_unregister_isr(omap_vout_isr, vout, mask);
+	omap_dispc_unregister_isr(omap_vout_isr, vout, IRQ_MASK);
 
 	for (j = 0; j < ovid->num_overlays; j++) {
 		struct omap_overlay *ovl = ovid->overlays[j];
@@ -2234,7 +1924,8 @@
 	vout->mirror = 0;
 	vout->control[2].id = V4L2_CID_HFLIP;
 	vout->control[2].value = 0;
-	vout->vrfb_bpp = 2;
+	if (vout->vid_info.rotation_type == VOUT_ROT_VRFB)
+		vout->vrfb_bpp = 2;
 
 	control[1].id = V4L2_CID_BG_COLOR;
 	control[1].value = 0;
@@ -2257,6 +1948,8 @@
 	mutex_init(&vout->lock);
 
 	vfd->minor = -1;
+	vfd->debug = debug;
+
 	return 0;
 
 }
@@ -2266,100 +1959,42 @@
 		int vid_num)
 {
 	u32 numbuffers;
-	int ret = 0, i, j;
-	int image_width, image_height;
-	struct video_device *vfd;
+	int ret = 0, i;
+	struct omapvideo_info *ovid;
 	struct omap_vout_device *vout;
-	int static_vrfb_allocation = 0, vrfb_num_bufs = VRFB_NUM_BUFS;
 	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
 	struct omap2video_device *vid_dev =
 		container_of(v4l2_dev, struct omap2video_device, v4l2_dev);
 
 	vout = vid_dev->vouts[vid_num];
-	vfd = vout->vfd;
+	ovid = &vout->vid_info;
 
-	numbuffers = (vid_num == 0) ? video1_numbuffers : video2_numbuffers;
+	numbuffers = num_default_buffers(vid_num);
 	vout->buffer_size = (vid_num == 0) ? video1_bufsize : video2_bufsize;
 	dev_info(&pdev->dev, "Buffer Size = %d\n", vout->buffer_size);
 
 	for (i = 0; i < numbuffers; i++) {
-		vout->buf_virt_addr[i] =
-			omap_vout_alloc_buffer(vout->buffer_size,
-					(u32 *) &vout->buf_phy_addr[i]);
-		if (!vout->buf_virt_addr[i]) {
+		if (omap_vout_alloc_buffer(&vout->buf[i], vout->buffer_size)) {
 			numbuffers = i;
 			ret = -ENOMEM;
 			goto free_buffers;
 		}
 	}
 
-	for (i = 0; i < VRFB_NUM_BUFS; i++) {
-		if (omap_vrfb_request_ctx(&vout->vrfb_context[i])) {
-			dev_info(&pdev->dev, ": VRFB allocation failed\n");
-			for (j = 0; j < i; j++)
-				omap_vrfb_release_ctx(&vout->vrfb_context[j]);
-			ret = -ENOMEM;
-			goto free_buffers;
-		}
-	}
 	vout->cropped_offset = 0;
 
-	/* Calculate VRFB memory size */
-	/* allocate for worst case size */
-	image_width = VID_MAX_WIDTH / TILE_SIZE;
-	if (VID_MAX_WIDTH % TILE_SIZE)
-		image_width++;
-
-	image_width = image_width * TILE_SIZE;
-	image_height = VID_MAX_HEIGHT / TILE_SIZE;
-
-	if (VID_MAX_HEIGHT % TILE_SIZE)
-		image_height++;
-
-	image_height = image_height * TILE_SIZE;
-	vout->smsshado_size = PAGE_ALIGN(image_width * image_height * 2 * 2);
-
-	/*
-	 * Request and Initialize DMA, for DMA based VRFB transfer
-	 */
-	vout->vrfb_dma_tx.dev_id = OMAP_DMA_NO_DEVICE;
-	vout->vrfb_dma_tx.dma_ch = -1;
-	vout->vrfb_dma_tx.req_status = DMA_CHAN_ALLOTED;
-	ret = omap_request_dma(vout->vrfb_dma_tx.dev_id, "VRFB DMA TX",
-			omap_vout_vrfb_dma_tx_callback,
-			(void *) &vout->vrfb_dma_tx, &vout->vrfb_dma_tx.dma_ch);
-	if (ret < 0) {
-		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
-		dev_info(&pdev->dev, ": failed to allocate DMA Channel for"
-				" video%d\n", vfd->minor);
-	}
-	init_waitqueue_head(&vout->vrfb_dma_tx.wait);
-
-	/* Allocate VRFB buffers if selected through bootargs */
-	static_vrfb_allocation = (vid_num == 0) ?
-		vid1_static_vrfb_alloc : vid2_static_vrfb_alloc;
-
-	/* statically allocated the VRFB buffer is done through
-	   commands line aruments */
-	if (static_vrfb_allocation) {
-		if (omap_vout_allocate_vrfb_buffers(vout, &vrfb_num_bufs, -1)) {
-			ret =  -ENOMEM;
-			goto release_vrfb_ctx;
-		}
-		vout->vrfb_static_allocation = 1;
+	if (ovid->rotation_type == VOUT_ROT_VRFB) {
+		int static_vrfb_allocation = (vid_num == 0) ?
+			vid1_static_vrfb_alloc : vid2_static_vrfb_alloc;
+		ret = omap_vout_setup_vrfb_bufs(pdev, vid_num,
+				static_vrfb_allocation);
 	}
-	return 0;
 
-release_vrfb_ctx:
-	for (j = 0; j < VRFB_NUM_BUFS; j++)
-		omap_vrfb_release_ctx(&vout->vrfb_context[j]);
+	return ret;
 
 free_buffers:
 	for (i = 0; i < numbuffers; i++) {
-		omap_vout_free_buffer(vout->buf_virt_addr[i],
-						vout->buffer_size);
-		vout->buf_virt_addr[i] = 0;
-		vout->buf_phy_addr[i] = 0;
+		omap_vout_free_buffer(&vout->buf[i]);
 	}
 	return ret;
 
@@ -2375,7 +2010,7 @@
 	struct omap2video_device *vid_dev = container_of(v4l2_dev,
 			struct omap2video_device, v4l2_dev);
 
-	for (k = 0; k < pdev->num_resources; k++) {
+	for (k = 0; k < vid_dev->num_overlays; k++) {
 
 		vout = kzalloc(sizeof(struct omap_vout_device), GFP_KERNEL);
 		if (!vout) {
@@ -2386,15 +2021,14 @@
 		vout->vid = k;
 		vid_dev->vouts[k] = vout;
 		vout->vid_dev = vid_dev;
-		/* Select video2 if only 1 overlay is controlled by V4L2 */
-		if (pdev->num_resources == 1)
-			vout->vid_info.overlays[0] = vid_dev->overlays[k + 2];
-		else
-			/* Else select video1 and video2 one by one. */
-			vout->vid_info.overlays[0] = vid_dev->overlays[k + 1];
+		vout->vid_info.overlays[0] = vid_dev->overlays[k];
 		vout->vid_info.num_overlays = 1;
 		vout->vid_info.id = k + 1;
 
+		/* Set VRFB as rotation_type for omap2 and omap3 */
+		if (cpu_is_omap24xx() || cpu_is_omap34xx())
+			vout->vid_info.rotation_type = VOUT_ROT_VRFB;
+
 		/* Setup the default configuration for the video devices
 		 */
 		if (omap_vout_setup_video_data(vout) != 0) {
@@ -2413,7 +2047,7 @@
 		/* Register the Video device with V4L2
 		 */
 		vfd = vout->vfd;
-		if (video_register_device(vfd, VFL_TYPE_GRABBER, -1) < 0) {
+		if (video_register_device(vfd, VFL_TYPE_GRABBER, k + 1) < 0) {
 			dev_err(&pdev->dev, ": Could not register "
 					"Video for Linux device\n");
 			vfd->minor = -1;
@@ -2423,12 +2057,13 @@
 		video_set_drvdata(vfd, vout);
 
 		/* Configure the overlay structure */
-		ret = omapvid_init(vid_dev->vouts[k], 0);
+		ret = omapvid_init(vid_dev->vouts[k], 0, 0);
 		if (!ret)
 			goto success;
 
 error2:
-		omap_vout_release_vrfb(vout);
+		if (vout->vid_info.rotation_type == VOUT_ROT_VRFB)
+			omap_vout_release_vrfb(vout);
 		omap_vout_free_buffers(vout);
 error1:
 		video_device_release(vfd);
@@ -2439,7 +2074,7 @@
 success:
 		dev_info(&pdev->dev, ": registered and initialized"
 				" video device %d\n", vfd->minor);
-		if (k == (pdev->num_resources - 1))
+		if (k == (vid_dev->num_overlays - 1))
 			return 0;
 	}
 
@@ -2449,11 +2084,13 @@
 static void omap_vout_cleanup_device(struct omap_vout_device *vout)
 {
 	struct video_device *vfd;
+	struct omapvideo_info *ovid;
 
 	if (!vout)
 		return;
 
 	vfd = vout->vfd;
+	ovid = &vout->vid_info;
 	if (vfd) {
 		if (!video_is_registered(vfd)) {
 			/*
@@ -2469,14 +2106,15 @@
 			video_unregister_device(vfd);
 		}
 	}
-
-	omap_vout_release_vrfb(vout);
+	if (ovid->rotation_type == VOUT_ROT_VRFB) {
+		omap_vout_release_vrfb(vout);
+		/* Free the VRFB buffer if allocated
+		 * init time
+		 */
+		if (vout->vrfb_static_allocation)
+			omap_vout_free_vrfb_buffers(vout);
+	}
 	omap_vout_free_buffers(vout);
-	/* Free the VRFB buffer if allocated
-	 * init time
-	 */
-	if (vout->vrfb_static_allocation)
-		omap_vout_free_vrfb_buffers(vout);
 
 	kfree(vout);
 }
@@ -2489,7 +2127,7 @@
 			omap2video_device, v4l2_dev);
 
 	v4l2_device_unregister(v4l2_dev);
-	for (k = 0; k < pdev->num_resources; k++)
+	for (k = 0; k < vid_dev->num_overlays; k++)
 		omap_vout_cleanup_device(vid_dev->vouts[k]);
 
 	for (k = 0; k < vid_dev->num_displays; k++) {
@@ -2504,11 +2142,12 @@
 
 static int __init omap_vout_probe(struct platform_device *pdev)
 {
-	int ret = 0, i;
-	struct omap_overlay *ovl;
+	int ret = 0, i, r, id_mgr;
+	struct omap_overlay *ovl, *gfx_ovl;
 	struct omap_dss_device *dssdev = NULL;
 	struct omap_dss_device *def_display;
 	struct omap2video_device *vid_dev = NULL;
+	struct omap_overlay_manager *mgr, *old_mgr;
 
 	if (pdev->num_resources == 0) {
 		dev_err(&pdev->dev, "probed for an unknown device\n");
@@ -2531,20 +2170,49 @@
 		goto probe_err0;
 	}
 
-	vid_dev->num_overlays = omap_dss_get_num_overlays();
-	for (i = 0; i < vid_dev->num_overlays; i++)
-		vid_dev->overlays[i] = omap_dss_get_overlay(i);
-
 	vid_dev->num_managers = omap_dss_get_num_overlay_managers();
 	for (i = 0; i < vid_dev->num_managers; i++)
 		vid_dev->managers[i] = omap_dss_get_overlay_manager(i);
 
-	/* Get the Video1 overlay and video2 overlay.
-	 * Setup the Display attached to that overlays
-	 */
-	for (i = 1; i < vid_dev->num_overlays; i++) {
+	gfx_ovl = omap_dss_get_overlay(0);
+	if (!gfx_ovl->manager) {
+		dev_err(&pdev->dev, "no manager for overlay 0\n");
+		ret = -EINVAL;
+		goto probe_err0;
+	}
+
+	vid_dev->num_overlays = 0;
+	id_mgr = gfx_ovl->manager->id;
+	mgr = omap_dss_get_overlay_manager(id_mgr);
+
+	for (i = 1; i < omap_dss_get_num_overlays(); i++) {
 		ovl = omap_dss_get_overlay(i);
-		if (ovl->manager && ovl->manager->device) {
+		if (mgr == ovl->manager)
+			goto next;
+		old_mgr = ovl->manager;
+		if (old_mgr) {
+			r = ovl->unset_manager(ovl);
+			if (r) {
+				dev_err(&pdev->dev, "dettach error: ovl->name %s\n", ovl->name);
+				continue;
+			}
+			r = old_mgr->apply(old_mgr);
+			if (r) {
+				dev_err(&pdev->dev, "apply error: old_mgr->name %s\n", old_mgr->name);
+				continue;
+			}
+		}
+		r = ovl->set_manager(ovl, mgr);
+		if (r) {
+			dev_err(&pdev->dev, "attach error: ovl->name %s, mgr->name %s\n", ovl->name, mgr->name);
+			continue;
+		}
+		r = mgr->apply(mgr);
+		if (r) {
+			dev_err(&pdev->dev, "apply error: mgr->name %s\n", mgr->name);
+			continue;
+		}
+		if (ovl->manager->device) {
 			def_display = ovl->manager->device;
 		} else {
 			dev_warn(&pdev->dev, "cannot find display\n");
@@ -2576,9 +2244,17 @@
 					dssdrv->set_update_mode(def_display,
 							OMAP_DSS_UPDATE_AUTO);
 			}
+next:
+			vid_dev->overlays[vid_dev->num_overlays++] = ovl;
 		}
 	}
 
+	if (vid_dev->num_overlays == 0) {
+		dev_err(&pdev->dev, "no free video overlays\n");
+		ret = -ENODEV;
+		goto probe_err0;
+	}
+
 	if (v4l2_device_register(&pdev->dev, &vid_dev->v4l2_dev) < 0) {
 		dev_err(&pdev->dev, "v4l2_device_register failed\n");
 		ret = -ENODEV;
@@ -2602,9 +2278,9 @@
 probe_err2:
 	v4l2_device_unregister(&vid_dev->v4l2_dev);
 probe_err1:
-	for (i = 1; i < vid_dev->num_overlays; i++) {
+	for (i = 0; i < vid_dev->num_overlays; i++) {
 		def_display = NULL;
-		ovl = omap_dss_get_overlay(i);
+		ovl = vid_dev->overlays[i];
 		if (ovl->manager && ovl->manager->device)
 			def_display = ovl->manager->device;
 
diff -urNP old/git/drivers/media/video/omap/omap_vout_vrfb.c new/git/drivers/media/video/omap/omap_vout_vrfb.c
--- old/git/drivers/media/video/omap/omap_vout_vrfb.c	1970-01-01 01:00:00.000000000 +0100
+++ new/git/drivers/media/video/omap/omap_vout_vrfb.c	2011-12-04 21:33:02.000000000 +0100
@@ -0,0 +1,381 @@
+/*
+ * omap_vout_vrfb.c
+ *
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/videodev2.h>
+
+#include <media/videobuf-dma-contig.h>
+#include <media/v4l2-device.h>
+
+#include <plat/dma.h>
+#include <plat/vrfb.h>
+
+#include "omap_voutdef.h"
+#include "omap_voutlib.h"
+
+/*
+ * Function for allocating video buffers
+ */
+static int omap_vout_allocate_vrfb_buffers(struct omap_vout_device *vout,
+		unsigned int *count, int startindex)
+{
+	int i, j;
+
+	for (i = 0; i < *count; i++) {
+		if (!vout->smsshado[i].paddr) {
+			omap_vout_alloc_buffer(&vout->smsshado[i], vout->smsshado_size);
+		}
+		if (!vout->smsshado[i].paddr && startindex != -1) {
+			if (V4L2_MEMORY_MMAP == vout->memory && i >= startindex)
+				break;
+		}
+		if (!vout->vout->smsshado[i].paddr) {
+			for (j = 0; j < i; j++) {
+				omap_vout_free_buffer(&vout->smsshado[j]);
+			}
+			*count = 0;
+			return -ENOMEM;
+		}
+		memset((void *) vout->vout->smsshado[i].paddr, 0,
+				vout->smsshado_size);
+	}
+	return 0;
+}
+
+/*
+ * Wakes up the application once the DMA transfer to VRFB space is completed.
+ */
+static void omap_vout_vrfb_dma_tx_callback(int lch, u16 ch_status, void *data)
+{
+	struct vid_vrfb_dma *t = (struct vid_vrfb_dma *) data;
+
+	t->tx_status = 1;
+	wake_up_interruptible(&t->wait);
+}
+
+/*
+ * Free VRFB buffers
+ */
+void omap_vout_free_vrfb_buffers(struct omap_vout_device *vout)
+{
+	int j;
+
+	for (j = 0; j < VRFB_NUM_BUFS; j++) {
+		omap_vout_free_buffer(&vout->smsshado[j]);
+	}
+}
+
+int omap_vout_setup_vrfb_bufs(struct platform_device *pdev, int vid_num,
+			u32 static_vrfb_allocation)
+{
+	int ret = 0, i, j;
+	struct omap_vout_device *vout;
+	struct video_device *vfd;
+	int image_width, image_height;
+	int vrfb_num_bufs = VRFB_NUM_BUFS;
+	struct v4l2_device *v4l2_dev = platform_get_drvdata(pdev);
+	struct omap2video_device *vid_dev =
+		container_of(v4l2_dev, struct omap2video_device, v4l2_dev);
+
+	vout = vid_dev->vouts[vid_num];
+	vfd = vout->vfd;
+
+	for (i = 0; i < VRFB_NUM_BUFS; i++) {
+		if (omap_vrfb_request_ctx(&vout->vrfb_context[i])) {
+			dev_info(&pdev->dev, ": VRFB allocation failed\n");
+			for (j = 0; j < i; j++)
+				omap_vrfb_release_ctx(&vout->vrfb_context[j]);
+			ret = -ENOMEM;
+			goto free_buffers;
+		}
+	}
+
+	/* Calculate VRFB memory size */
+	/* allocate for worst case size */
+	image_width = VID_MAX_WIDTH / TILE_SIZE;
+	if (VID_MAX_WIDTH % TILE_SIZE)
+		image_width++;
+
+	image_width = image_width * TILE_SIZE;
+	image_height = VID_MAX_HEIGHT / TILE_SIZE;
+
+	if (VID_MAX_HEIGHT % TILE_SIZE)
+		image_height++;
+
+	image_height = image_height * TILE_SIZE;
+	vout->smsshado_size = PAGE_ALIGN(image_width * image_height * 2 * 2);
+
+	/*
+	 * Request and Initialize DMA, for DMA based VRFB transfer
+	 */
+	vout->vrfb_dma_tx.dev_id = OMAP_DMA_NO_DEVICE;
+	vout->vrfb_dma_tx.dma_ch = -1;
+	vout->vrfb_dma_tx.req_status = DMA_CHAN_ALLOTED;
+	ret = omap_request_dma(vout->vrfb_dma_tx.dev_id, "VRFB DMA TX",
+			omap_vout_vrfb_dma_tx_callback,
+			(void *) &vout->vrfb_dma_tx, &vout->vrfb_dma_tx.dma_ch);
+	if (ret < 0) {
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+		dev_info(&pdev->dev, ": failed to allocate DMA Channel for"
+				" video%d\n", vfd->minor);
+	}
+	init_waitqueue_head(&vout->vrfb_dma_tx.wait);
+
+	/* statically allocated the VRFB buffer is done through
+	   commands line aruments */
+	if (static_vrfb_allocation) {
+		if (omap_vout_allocate_vrfb_buffers(vout, &vrfb_num_bufs, -1)) {
+			ret =  -ENOMEM;
+			goto release_vrfb_ctx;
+		}
+		vout->vrfb_static_allocation = 1;
+	}
+	return 0;
+
+release_vrfb_ctx:
+	for (j = 0; j < VRFB_NUM_BUFS; j++)
+		omap_vrfb_release_ctx(&vout->vrfb_context[j]);
+free_buffers:
+	omap_vout_free_buffers(vout);
+
+	return ret;
+}
+
+/*
+ * Release the VRFB context once the module exits
+ */
+void omap_vout_release_vrfb(struct omap_vout_device *vout)
+{
+	int i;
+
+	for (i = 0; i < VRFB_NUM_BUFS; i++)
+		omap_vrfb_release_ctx(&vout->vrfb_context[i]);
+
+	if (vout->vrfb_dma_tx.req_status == DMA_CHAN_ALLOTED) {
+		vout->vrfb_dma_tx.req_status = DMA_CHAN_NOT_ALLOTED;
+		omap_free_dma(vout->vrfb_dma_tx.dma_ch);
+	}
+}
+
+/*
+ * Allocate the buffers for the VRFB space.  Data is copied from V4L2
+ * buffers to the VRFB buffers using the DMA engine.
+ */
+int omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,
+			  unsigned int *count, unsigned int startindex)
+{
+	int i;
+	bool yuv_mode;
+
+	if (!rotation_enabled(vout))
+		return 0;
+
+	/* If rotation is enabled, allocate memory for VRFB space also */
+	*count = *count > VRFB_NUM_BUFS ? VRFB_NUM_BUFS : *count;
+
+	/* Allocate the VRFB buffers only if the buffers are not
+	 * allocated during init time.
+	 */
+	if (!vout->vrfb_static_allocation)
+		if (omap_vout_allocate_vrfb_buffers(vout, count, startindex))
+			return -ENOMEM;
+
+	if (vout->dss_mode == OMAP_DSS_COLOR_YUV2 ||
+			vout->dss_mode == OMAP_DSS_COLOR_UYVY)
+		yuv_mode = true;
+	else
+		yuv_mode = false;
+
+	for (i = 0; i < *count; i++)
+		omap_vrfb_setup(&vout->vrfb_context[i],
+				vout->smsshado[i].paddr, vout->pix.width,
+				vout->pix.height, vout->bpp, yuv_mode);
+
+	return 0;
+}
+
+int omap_vout_prepare_vrfb(struct omap_vout_device *vout,
+				struct videobuf_buffer *vb)
+{
+	dma_addr_t dmabuf;
+	struct vid_vrfb_dma *tx;
+	enum dss_rotation rotation;
+	u32 dest_frame_index = 0, src_element_index = 0;
+	u32 dest_element_index = 0, src_frame_index = 0;
+	u32 elem_count = 0, frame_count = 0, pixsize = 2;
+
+	if (!rotation_enabled(vout))
+		return 0;
+
+	dmabuf = vout->buf[vb->i].paddr;
+	/* If rotation is enabled, copy input buffer into VRFB
+	 * memory space using DMA. We are copying input buffer
+	 * into VRFB memory space of desired angle and DSS will
+	 * read image VRFB memory for 0 degree angle
+	 */
+	pixsize = vout->bpp * vout->vrfb_bpp;
+	/*
+	 * DMA transfer in double index mode
+	 */
+
+	/* Frame index */
+	dest_frame_index = ((MAX_PIXELS_PER_LINE * pixsize) -
+			(vout->pix.width * vout->bpp)) + 1;
+
+	/* Source and destination parameters */
+	src_element_index = 0;
+	src_frame_index = 0;
+	dest_element_index = 1;
+	/* Number of elements per frame */
+	elem_count = vout->pix.width * vout->bpp;
+	frame_count = vout->pix.height;
+	tx = &vout->vrfb_dma_tx;
+	tx->tx_status = 0;
+	omap_set_dma_transfer_params(tx->dma_ch, OMAP_DMA_DATA_TYPE_S32,
+			(elem_count / 4), frame_count, OMAP_DMA_SYNC_ELEMENT,
+			tx->dev_id, 0x0);
+	/* src_port required only for OMAP1 */
+	omap_set_dma_src_params(tx->dma_ch, 0, OMAP_DMA_AMODE_POST_INC,
+			dmabuf, src_element_index, src_frame_index);
+	/*set dma source burst mode for VRFB */
+	omap_set_dma_src_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);
+	rotation = calc_rotation(vout);
+
+	/* dest_port required only for OMAP1 */
+	omap_set_dma_dest_params(tx->dma_ch, 0, OMAP_DMA_AMODE_DOUBLE_IDX,
+			vout->vrfb_context[vb->i].paddr[0], dest_element_index,
+			dest_frame_index);
+	/*set dma dest burst mode for VRFB */
+	omap_set_dma_dest_burst_mode(tx->dma_ch, OMAP_DMA_DATA_BURST_16);
+	omap_dma_set_global_params(DMA_DEFAULT_ARB_RATE, 0x20, 0);
+
+	omap_start_dma(tx->dma_ch);
+	interruptible_sleep_on_timeout(&tx->wait, VRFB_TX_TIMEOUT);
+
+	if (tx->tx_status == 0) {
+		omap_stop_dma(tx->dma_ch);
+		return -EINVAL;
+	}
+	/* Store buffers physical address into an array. Addresses
+	 * from this array will be used to configure DSS */
+	vout->queued_buf_addr[vb->i] = (u8 *)
+		vout->vrfb_context[vb->i].paddr[rotation];
+	return 0;
+}
+
+/*
+ * Calculate the buffer offsets from which the streaming should
+ * start. This offset calculation is mainly required because of
+ * the VRFB 32 pixels alignment with rotation.
+ */
+void omap_vout_calculate_vrfb_offset(struct omap_vout_device *vout)
+{
+	enum dss_rotation rotation;
+	bool mirroring = vout->mirror;
+	struct v4l2_rect *crop = &vout->crop;
+	struct v4l2_pix_format *pix = &vout->pix;
+	int *cropped_offset = &vout->cropped_offset;
+	int vr_ps = 1, ps = 2, temp_ps = 2;
+	int offset = 0, ctop = 0, cleft = 0, line_length = 0;
+
+	rotation = calc_rotation(vout);
+
+	if (V4L2_PIX_FMT_YUYV == pix->pixelformat ||
+			V4L2_PIX_FMT_UYVY == pix->pixelformat) {
+		if (rotation_enabled(vout)) {
+			/*
+			 * ps    - Actual pixel size for YUYV/UYVY for
+			 *         VRFB/Mirroring is 4 bytes
+			 * vr_ps - Virtually pixel size for YUYV/UYVY is
+			 *         2 bytes
+			 */
+			ps = 4;
+			vr_ps = 2;
+		} else {
+			ps = 2;	/* otherwise the pixel size is 2 byte */
+		}
+	} else if (V4L2_PIX_FMT_RGB32 == pix->pixelformat) {
+		ps = 4;
+	} else if (V4L2_PIX_FMT_RGB24 == pix->pixelformat) {
+		ps = 3;
+	}
+	vout->ps = ps;
+	vout->vr_ps = vr_ps;
+
+	if (rotation_enabled(vout)) {
+		line_length = MAX_PIXELS_PER_LINE;
+		ctop = (pix->height - crop->height) - crop->top;
+		cleft = (pix->width - crop->width) - crop->left;
+	} else {
+		line_length = pix->width;
+	}
+	vout->line_length = line_length;
+	switch (rotation) {
+	case dss_rotation_90_degree:
+		offset = vout->vrfb_context[0].yoffset *
+			vout->vrfb_context[0].bytespp;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+				temp_ps * cleft + crop->top * temp_ps;
+		} else {
+			*cropped_offset = offset + line_length * temp_ps *
+				cleft + crop->top * temp_ps + (line_length *
+				((crop->width / (vr_ps)) - 1) * ps);
+		}
+		break;
+	case dss_rotation_180_degree:
+		offset = ((MAX_PIXELS_PER_LINE * vout->vrfb_context[0].yoffset *
+			vout->vrfb_context[0].bytespp) +
+			(vout->vrfb_context[0].xoffset *
+			vout->vrfb_context[0].bytespp));
+		if (mirroring == 0) {
+			*cropped_offset = offset + (line_length * ps * ctop) +
+				(cleft / vr_ps) * ps;
+
+		} else {
+			*cropped_offset = offset + (line_length * ps * ctop) +
+				(cleft / vr_ps) * ps + (line_length *
+				(crop->height - 1) * ps);
+		}
+		break;
+	case dss_rotation_270_degree:
+		offset = MAX_PIXELS_PER_LINE * vout->vrfb_context[0].xoffset *
+			vout->vrfb_context[0].bytespp;
+		temp_ps = ps / vr_ps;
+		if (mirroring == 0) {
+			*cropped_offset = offset + line_length *
+			    temp_ps * crop->left + ctop * ps;
+		} else {
+			*cropped_offset = offset + line_length *
+				temp_ps * crop->left + ctop * ps +
+				(line_length * ((crop->width / vr_ps) - 1) *
+				 ps);
+		}
+		break;
+	case dss_rotation_0_degree:
+		if (mirroring == 0) {
+			*cropped_offset = (line_length * ps) *
+				crop->top + (crop->left / vr_ps) * ps;
+		} else {
+			*cropped_offset = (line_length * ps) *
+				crop->top + (crop->left / vr_ps) * ps +
+				(line_length * (crop->height - 1) * ps);
+		}
+		break;
+	default:
+		*cropped_offset = (line_length * ps * crop->top) /
+			vr_ps + (crop->left * ps) / vr_ps +
+			((crop->width / vr_ps) - 1) * ps;
+		break;
+	}
+}
diff -urNP old/git/drivers/media/video/omap/omap_vout_vrfb.h new/git/drivers/media/video/omap/omap_vout_vrfb.h
--- old/git/drivers/media/video/omap/omap_vout_vrfb.h	1970-01-01 01:00:00.000000000 +0100
+++ new/git/drivers/media/video/omap/omap_vout_vrfb.h	2011-12-04 21:33:02.000000000 +0100
@@ -0,0 +1,40 @@
+/*
+ * omap_vout_vrfb.h
+ *
+ * Copyright (C) 2010 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#ifndef OMAP_VOUT_VRFB_H
+#define OMAP_VOUT_VRFB_H
+
+#ifdef CONFIG_VIDEO_OMAP2_VOUT_VRFB
+void omap_vout_free_vrfb_buffers(struct omap_vout_device *vout);
+int omap_vout_setup_vrfb_bufs(struct platform_device *pdev, int vid_num,
+			u32 static_vrfb_allocation);
+void omap_vout_release_vrfb(struct omap_vout_device *vout);
+int omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,
+			unsigned int *count, unsigned int startindex);
+int omap_vout_prepare_vrfb(struct omap_vout_device *vout,
+			struct videobuf_buffer *vb);
+void omap_vout_calculate_vrfb_offset(struct omap_vout_device *vout);
+#else
+void omap_vout_free_vrfb_buffers(struct omap_vout_device *vout) { }
+int omap_vout_setup_vrfb_bufs(struct platform_device *pdev, int vid_num,
+			u32 static_vrfb_allocation)
+		{ return 0; }
+void omap_vout_release_vrfb(struct omap_vout_device *vout) { }
+int omap_vout_vrfb_buffer_setup(struct omap_vout_device *vout,
+			unsigned int *count, unsigned int startindex)
+		{ return 0; }
+int omap_vout_prepare_vrfb(struct omap_vout_device *vout,
+			struct videobuf_buffer *vb)
+		{ return 0; }
+void omap_vout_calculate_vrfb_offset(struct omap_vout_device *vout) { }
+#endif
+
+#endif
diff -urNP old/git/drivers/media/video/omap/omap_voutdef.h new/git/drivers/media/video/omap/omap_voutdef.h
--- old/git/drivers/media/video/omap/omap_voutdef.h	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/omap_voutdef.h	2011-12-04 21:33:02.000000000 +0100
@@ -11,8 +11,12 @@
 #ifndef OMAP_VOUTDEF_H
 #define OMAP_VOUTDEF_H
 
+#include <plat/vrfb.h>
+
 #include <video/omapdss.h>
 
+#include "omap_voutlib.h"
+
 #define YUYV_BPP        2
 #define RGB565_BPP      2
 #define RGB24_BPP       3
@@ -22,11 +26,42 @@
 #define RGB_VRFB_BPP    1
 #define MAX_CID		3
 #define MAC_VRFB_CTXS	4
-#define MAX_VOUT_DEV	2
+#define MAX_VOUT_DEV	3
 #define MAX_OVLS	3
 #define MAX_DISPLAYS	3
 #define MAX_MANAGERS	3
 
+#define QQVGA_WIDTH		160
+#define QQVGA_HEIGHT		120
+
+/* Max Resolution supported by the driver */
+/* note: max viewable area may be lower.. but for example, 1080p h264
+ * playback requires buffers with a padded size of 2048x1184.  The
+ * viewable area may only be 1920x1080, but the total buffer size is
+ * larger.  There isn't really a way to express this properly, so we
+ * just pretend we can support 2048x2048
+ */
+#define VID_MAX_WIDTH		2048
+#define VID_MAX_HEIGHT		2048
+
+/* Mimimum requirement is 2x2 for DSS */
+#define VID_MIN_WIDTH		2
+#define VID_MIN_HEIGHT		2
+
+/* 2048 x 2048 is max res supported by OMAP display controller */
+#define MAX_PIXELS_PER_LINE     2048
+
+#define VRFB_TX_TIMEOUT         1000
+#define VRFB_NUM_BUFS		4
+
+/* Max buffer size tobe allocated during init */
+#define OMAP_VOUT_MAX_BUF_SIZE (VID_MAX_WIDTH*VID_MAX_HEIGHT*4)
+
+enum dma_channel_state {
+	DMA_CHAN_NOT_ALLOTED,
+	DMA_CHAN_ALLOTED,
+};
+
 /* Enum for Rotation
  * DSS understands rotation in 0, 1, 2, 3 context
  * while V4L2 driver understands it as 0, 90, 180, 270
@@ -37,6 +72,18 @@
 	dss_rotation_180_degree	= 2,
 	dss_rotation_270_degree = 3,
 };
+
+/* Enum for choosing rotation type for vout
+ * DSS2 doesn't understand no rotation as an
+ * option while V4L2 driver doesn't support
+ * rotation in the case where VRFB is not built in
+ * the kernel
+ */
+enum vout_rotaion_type {
+	VOUT_ROT_NONE	= 0,
+	VOUT_ROT_VRFB	= 1,
+};
+
 /*
  * This structure is used to store the DMA transfer parameters
  * for VRFB hidden buffer
@@ -53,6 +100,7 @@
 	int id;
 	int num_overlays;
 	struct omap_overlay *overlays[MAX_OVLS];
+	enum vout_rotaion_type rotation_type;
 };
 
 struct omap2video_device {
@@ -87,8 +135,8 @@
 	/* allow to reuse previously allocated buffer which is big enough */
 	int buffer_size;
 	/* keep buffer info across opens */
-	unsigned long buf_virt_addr[VIDEO_MAX_FRAME];
-	unsigned long buf_phy_addr[VIDEO_MAX_FRAME];
+	struct omap_vout_buffer buf[VIDEO_MAX_FRAME];
+
 	enum omap_color_mode dss_mode;
 
 	/* we don't allow to request new buffer when old buffers are
@@ -121,11 +169,10 @@
 	int vrfb_bpp; /* bytes per pixel with respect to VRFB */
 
 	struct vid_vrfb_dma vrfb_dma_tx;
-	unsigned int smsshado_phy_addr[MAC_VRFB_CTXS];
-	unsigned int smsshado_virt_addr[MAC_VRFB_CTXS];
+	struct omap_vout_buffer smsshado[MAC_VRFB_CTXS];
+	unsigned int smsshado_size;
 	struct vrfb vrfb_context[MAC_VRFB_CTXS];
 	bool vrfb_static_allocation;
-	unsigned int smsshado_size;
 	unsigned char pos;
 
 	int ps, vr_ps, line_length, first_int, field_id;
@@ -133,7 +180,9 @@
 	struct videobuf_buffer *cur_frm, *next_frm;
 	struct list_head dma_queue;
 	u8 *queued_buf_addr[VIDEO_MAX_FRAME];
+	u8 *queued_buf_uv_addr[VIDEO_MAX_FRAME];
 	u32 cropped_offset;
+	u32 cropped_uv_offset;
 	s32 tv_field1_offset;
 	void *isr_handle;
 
@@ -144,4 +193,43 @@
 	int io_allowed;
 
 };
+
+/*
+ * Return true if rotation is 90 or 270
+ */
+static inline int rotate_90_or_270(const struct omap_vout_device *vout)
+{
+	return (vout->rotation == dss_rotation_90_degree ||
+			vout->rotation == dss_rotation_270_degree);
+}
+
+/*
+ * Return true if rotation is enabled
+ */
+static inline int rotation_enabled(const struct omap_vout_device *vout)
+{
+	return vout->rotation || vout->mirror;
+}
+
+/*
+ * Reverse the rotation degree if mirroring is enabled
+ */
+static inline int calc_rotation(const struct omap_vout_device *vout)
+{
+	if (!vout->mirror)
+		return vout->rotation;
+
+	switch (vout->rotation) {
+	case dss_rotation_90_degree:
+		return dss_rotation_270_degree;
+	case dss_rotation_270_degree:
+		return dss_rotation_90_degree;
+	case dss_rotation_180_degree:
+		return dss_rotation_0_degree;
+	default:
+		return dss_rotation_180_degree;
+	}
+}
+
+void omap_vout_free_buffers(struct omap_vout_device *vout);
 #endif	/* ifndef OMAP_VOUTDEF_H */
diff -urNP old/git/drivers/media/video/omap/omap_voutlib.c new/git/drivers/media/video/omap/omap_voutlib.c
--- old/git/drivers/media/video/omap/omap_voutlib.c	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/omap_voutlib.c	2011-12-04 21:33:02.000000000 +0100
@@ -24,8 +24,13 @@
 #include <linux/types.h>
 #include <linux/videodev2.h>
 
+#include <linux/dma-mapping.h>
+
 #include <plat/cpu.h>
 
+#include "omap_voutlib.h"
+
+
 MODULE_AUTHOR("Texas Instruments");
 MODULE_DESCRIPTION("OMAP Video library");
 MODULE_LICENSE("GPL");
@@ -53,7 +58,7 @@
 /* Given a new render window in new_win, adjust the window to the
  * nearest supported configuration.  The adjusted window parameters are
  * returned in new_win.
- * Returns zero if successful, or -EINVAL if the requested window is
+ * Returns zero if succesful, or -EINVAL if the requested window is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_try_window(struct v4l2_framebuffer *fbuf,
@@ -101,7 +106,7 @@
  * will also be adjusted if necessary.  Preference is given to keeping the
  * the window as close to the requested configuration as possible.  If
  * successful, new_win, vout->win, and crop are updated.
- * Returns zero if successful, or -EINVAL if the requested preview window is
+ * Returns zero if succesful, or -EINVAL if the requested preview window is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_new_window(struct v4l2_rect *crop,
@@ -155,7 +160,7 @@
  * window would fall outside the display boundaries, the cropping rectangle
  * will also be adjusted to maintain the rescaling ratios.  If successful, crop
  * and win are updated.
- * Returns zero if successful, or -EINVAL if the requested cropping rectangle is
+ * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
  * impossible and cannot reasonably be adjusted.
  */
 int omap_vout_new_crop(struct v4l2_pix_format *pix,
@@ -193,7 +198,7 @@
 		return -EINVAL;
 
 	if (cpu_is_omap24xx()) {
-		if (try_crop.height != win->w.height) {
+		if (crop->height != win->w.height) {
 			/* If we're resizing vertically, we can't support a
 			 * crop width wider than 768 pixels.
 			 */
@@ -202,7 +207,7 @@
 		}
 	}
 	/* vertical resizing */
-	vresize = (1024 * try_crop.height) / win->w.height;
+	vresize = (1024 * crop->height) / win->w.height;
 	if (cpu_is_omap24xx() && (vresize > 2048))
 		vresize = 2048;
 	else if (cpu_is_omap34xx() && (vresize > 4096))
@@ -221,7 +226,7 @@
 			try_crop.height = 2;
 	}
 	/* horizontal resizing */
-	hresize = (1024 * try_crop.width) / win->w.width;
+	hresize = (1024 * crop->width) / win->w.width;
 	if (cpu_is_omap24xx() && (hresize > 2048))
 		hresize = 2048;
 	else if (cpu_is_omap34xx() && (hresize > 4096))
@@ -291,3 +296,87 @@
 }
 EXPORT_SYMBOL_GPL(omap_vout_new_format);
 
+/*
+ * Allocate buffers
+ */
+int omap_vout_alloc_buffer(struct omap_vout_buffer *buf, u32 buf_size)
+{
+	unsigned long addr;
+	u32 order, size;
+
+	size = PAGE_ALIGN(buf_size);
+
+#ifdef CONFIG_TI_TILER
+	if (cpu_is_omap44xx()) {
+		buf->blk.width = size;
+		buf->blk.height = 1;
+		buf->blk.key = 1; // XXX ???
+
+		if (tiler_alloc(&buf->blk, TILFMT_PAGE, PAGE_SIZE, 0))
+			goto fail;
+
+		buf->paddr = buf->blk.phys;
+		buf->size = size;
+
+
+		return 0;
+	}
+#endif
+
+	order = get_order(size);
+
+	buf->vaddr = __get_free_pages(GFP_KERNEL | GFP_DMA, order);
+	addr = buf->vaddr;
+
+	if (!buf->vaddr)
+		goto fail;
+
+	buf->size = size;
+
+	while (size > 0) {
+		SetPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	buf->paddr = (u32) virt_to_phys((void *) buf->vaddr);
+
+	return 0;
+fail:
+	memset(buf, 0, sizeof(*buf));
+	return -ENOMEM;
+}
+
+/*
+ * Free buffers
+ */
+void omap_vout_free_buffer(struct omap_vout_buffer *buf)
+{
+	u32 order, size;
+	unsigned long vaddr;
+
+	if (!buf->paddr)
+		return;
+
+	size = buf->size;
+
+#ifdef CONFIG_TI_TILER
+	if (cpu_is_omap44xx()) {
+		tiler_free(&buf->blk);
+		memset(buf, 0, sizeof(*buf));
+		return;
+	}
+#endif
+
+	vaddr = buf->vaddr;
+	order = get_order(size);
+
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(vaddr));
+		vaddr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages((unsigned long) buf->vaddr, order);
+
+	memset(buf, 0, sizeof(*buf));
+}
diff -urNP old/git/drivers/media/video/omap/omap_voutlib.h new/git/drivers/media/video/omap/omap_voutlib.h
--- old/git/drivers/media/video/omap/omap_voutlib.h	2011-10-24 09:43:19.000000000 +0200
+++ new/git/drivers/media/video/omap/omap_voutlib.h	2011-12-04 21:33:02.000000000 +0100
@@ -12,6 +12,10 @@
 #ifndef OMAP_VOUTLIB_H
 #define OMAP_VOUTLIB_H
 
+#ifdef CONFIG_TI_TILER
+#  include <mach/tiler.h>
+#endif
+
 extern void omap_vout_default_crop(struct v4l2_pix_format *pix,
 		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop);
 
@@ -30,5 +34,17 @@
 extern void omap_vout_new_format(struct v4l2_pix_format *pix,
 		struct v4l2_framebuffer *fbuf, struct v4l2_rect *crop,
 		struct v4l2_window *win);
+
+struct omap_vout_buffer {
+	unsigned long size;
+	unsigned long vaddr;		/* could be NULL if no kernel mapping */
+	unsigned long paddr;
+#ifdef CONFIG_TI_TILER
+	struct tiler_block_t blk;
+#endif
+};
+
+int omap_vout_alloc_buffer(struct omap_vout_buffer *buf, u32 buf_size);
+void omap_vout_free_buffer(struct omap_vout_buffer *buf);
 #endif	/* #ifndef OMAP_VOUTLIB_H */
 
diff -urNP old/git/drivers/video/omap2/dss/dispc.c new/git/drivers/video/omap2/dss/dispc.c
--- old/git/drivers/video/omap2/dss/dispc.c	2011-10-24 09:43:34.000000000 +0200
+++ new/git/drivers/video/omap2/dss/dispc.c	2011-12-04 21:33:25.000000000 +0100
@@ -1698,6 +1698,9 @@
 			fclk <<= 1;
 	}
 
+	if (fclk == 0)
+		fclk = dispc_fclk_rate();
+
 	return fclk;
 }
 
@@ -1800,7 +1803,7 @@
 			cconv = 1;
 
 		/* Must use 5-tap filter? */
-		five_taps = height > out_height * 2;
+		five_taps = (height > out_height * 2) || (out_height > height * 2);
 
 		if (!five_taps) {
 			fclk = calc_fclk(channel, width, height, out_width,
diff -urNP old/git/drivers/video/omap2/dss/dispc.h new/git/drivers/video/omap2/dss/dispc.h
--- old/git/drivers/video/omap2/dss/dispc.h	2011-10-24 09:43:34.000000000 +0200
+++ new/git/drivers/video/omap2/dss/dispc.h	2011-12-04 21:33:25.000000000 +0100
@@ -172,9 +172,8 @@
 {
 	switch (channel) {
 	case OMAP_DSS_CHANNEL_LCD:
-		return 0x0070;
 	case OMAP_DSS_CHANNEL_DIGIT:
-		BUG();
+		return 0x0070;
 	case OMAP_DSS_CHANNEL_LCD2:
 		return 0x040C;
 	default:
