From 57cd32e93425597317b4b7722859155419836e4c Mon Sep 17 00:00:00 2001
From: Aaron Plattner <aplattner@nvidia.com>
Date: Thu, 25 Aug 2011 15:41:55 -0700
Subject: [PATCH 2/2] xfree86/modes: Make cursor position transform a helper function

When the driver can handle the crtc transform in hardware, it sets
crtc->driverIsPerformingTransform, which turns off both the shadow
layer and the cursor's position-transforming code.  However, some
drivers actually do require the cursor position to still be
transformed in these cases.  Move the cursor position transform into a
helper function that can be called by such drivers.

Signed-off-by: Aaron Plattner <aplattner@nvidia.com>
---
 hw/xfree86/modes/xf86Crtc.h    |    8 +++++
 hw/xfree86/modes/xf86Cursors.c |   57 +++++++++++++++++++++------------------
 2 files changed, 39 insertions(+), 26 deletions(-)

Index: xserver/hw/xfree86/modes/xf86Crtc.h
===================================================================
--- xserver.orig/hw/xfree86/modes/xf86Crtc.h	2012-03-21 16:16:55.085740513 +0100
+++ xserver/hw/xfree86/modes/xf86Crtc.h	2012-03-21 16:16:55.121740513 +0100
@@ -903,6 +903,14 @@
 extern _X_EXPORT char *
 xf86ConnectorGetName(xf86ConnectorType connector);
 
+/**
+ * Transform the cursor's coordinates based on the crtc transform.  Normally
+ * this is done by the server, but if crtc->driverIsPerformingTransform is TRUE,
+ * then the server does not transform the cursor position automatically.
+ */
+extern _X_EXPORT void
+xf86CrtcTransformCursorPos (xf86CrtcPtr crtc, int *x, int *y);
+
 /*
  * Using the desired mode information in each crtc, set
  * modes (used in EnterVT functions, or at server startup)
Index: xserver/hw/xfree86/modes/xf86Cursors.c
===================================================================
--- xserver.orig/hw/xfree86/modes/xf86Cursors.c	2012-03-21 16:16:55.089740513 +0100
+++ xserver/hw/xfree86/modes/xf86Cursors.c	2012-03-21 16:16:55.121740513 +0100
@@ -337,7 +337,36 @@
 	    xf86_crtc_show_cursor (crtc);
     }
 }
-    
+
+void xf86CrtcTransformCursorPos (xf86CrtcPtr crtc, int *x, int *y)
+{
+    ScrnInfoPtr scrn = crtc->scrn;
+    ScreenPtr screen = scrn->pScreen;
+    xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+    xf86CursorInfoPtr cursor_info = xf86_config->cursor_info;
+    xf86CursorScreenPtr ScreenPriv =
+	(xf86CursorScreenPtr)dixLookupPrivate(&screen->devPrivates,
+					      xf86CursorScreenKey);
+    struct pict_f_vector v;
+    int dx, dy;
+
+    v.v[0] = (*x + ScreenPriv->HotX) + 0.5;
+    v.v[1] = (*y + ScreenPriv->HotY) + 0.5;
+    v.v[2] = 1;
+    pixman_f_transform_point (&crtc->f_framebuffer_to_crtc, &v);
+    /* cursor will have 0.5 added to it already so floor is sufficent */
+    *x = floor (v.v[0]);
+    *y = floor (v.v[1]);
+    /*
+     * Transform position of cursor upper left corner
+     */
+    xf86_crtc_rotate_coord_back (crtc->rotation, cursor_info->MaxWidth,
+				 cursor_info->MaxHeight, ScreenPriv->HotX,
+				 ScreenPriv->HotY, &dx, &dy);
+    *x -= dx;
+    *y -= dy;
+}
+
 static void
 xf86_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
 {
@@ -346,36 +375,12 @@
     xf86CursorInfoPtr	cursor_info = xf86_config->cursor_info;
     DisplayModePtr	mode = &crtc->mode;
     Bool		in_range;
-    int			dx, dy;
 
     /*
      * Transform position of cursor on screen
      */
     if (crtc->transform_in_use && !crtc->driverIsPerformingTransform)
-    {
-	ScreenPtr	screen = scrn->pScreen;
-	xf86CursorScreenPtr ScreenPriv =
-	    (xf86CursorScreenPtr)dixLookupPrivate(&screen->devPrivates,
-						  xf86CursorScreenKey);
-	struct pict_f_vector   v;
-
-	v.v[0] = (x + ScreenPriv->HotX) + 0.5;
-	v.v[1] = (y + ScreenPriv->HotY) + 0.5;
-	v.v[2] = 1;
-	pixman_f_transform_point (&crtc->f_framebuffer_to_crtc, &v);
-	/* cursor will have 0.5 added to it already so floor is sufficent */
-	x = floor (v.v[0]);
-	y = floor (v.v[1]);
-	/*
-	 * Transform position of cursor upper left corner
-	 */
-	xf86_crtc_rotate_coord_back (crtc->rotation,
-				     cursor_info->MaxWidth,
-				     cursor_info->MaxHeight,
-				     ScreenPriv->HotX, ScreenPriv->HotY, &dx, &dy);
-	x -= dx;
-	y -= dy;
-   }
+	xf86CrtcTransformCursorPos(crtc, &x, &y);
     else
     {
 	x -= crtc->x;
